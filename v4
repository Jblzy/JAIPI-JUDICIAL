# JAIPI-JUDICIAL V4 - COMPLETE GOVERNMENT API & LAW WATCHDOG SYSTEM

## Full Implementation - Maximum Agent Deployment

---

## ðŸ“ COMPLETE PROJECT STRUCTURE

```
JAIPI-JUDICIAL-V4/
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ setup.py
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ Makefile
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py
â”‚   â”œâ”€â”€ constants.py
â”‚   â”œâ”€â”€ api_endpoints.py
â”‚   â”œâ”€â”€ jurisdictions.py
â”‚   â”œâ”€â”€ legal_codes.py
â”‚   â”œâ”€â”€ agency_registry.py
â”‚   â”œâ”€â”€ compliance_rules.py
â”‚   â””â”€â”€ security_config.py
â”‚
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ engine.py
â”‚   â”œâ”€â”€ orchestrator.py
â”‚   â”œâ”€â”€ state_machine.py
â”‚   â”œâ”€â”€ event_bus.py
â”‚   â”œâ”€â”€ message_queue.py
â”‚   â”œâ”€â”€ scheduler.py
â”‚   â”œâ”€â”€ cache_manager.py
â”‚   â””â”€â”€ context_manager.py
â”‚
â”œâ”€â”€ agents/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_agent.py
â”‚   â”œâ”€â”€ watchdog_agent.py
â”‚   â”œâ”€â”€ compliance_agent.py
â”‚   â”œâ”€â”€ citation_agent.py
â”‚   â”œâ”€â”€ precedent_agent.py
â”‚   â”œâ”€â”€ statutory_agent.py
â”‚   â”œâ”€â”€ constitutional_agent.py
â”‚   â”œâ”€â”€ regulatory_agent.py
â”‚   â”œâ”€â”€ procedural_agent.py
â”‚   â”œâ”€â”€ evidence_agent.py
â”‚   â”œâ”€â”€ sentiment_agent.py
â”‚   â”œâ”€â”€ risk_agent.py
â”‚   â”œâ”€â”€ audit_agent.py
â”‚   â”œâ”€â”€ notification_agent.py
â”‚   â”œâ”€â”€ coordination_agent.py
â”‚   â”œâ”€â”€ foia_agent.py
â”‚   â”œâ”€â”€ ethics_agent.py
â”‚   â”œâ”€â”€ jurisdiction_agent.py
â”‚   â”œâ”€â”€ timeline_agent.py
â”‚   â”œâ”€â”€ document_agent.py
â”‚   â”œâ”€â”€ api_monitor_agent.py
â”‚   â”œâ”€â”€ budget_agent.py
â”‚   â”œâ”€â”€ transparency_agent.py
â”‚   â”œâ”€â”€ whistleblower_agent.py
â”‚   â”œâ”€â”€ contract_agent.py
â”‚   â”œâ”€â”€ administrative_agent.py
â”‚   â”œâ”€â”€ enforcement_agent.py
â”‚   â”œâ”€â”€ appeals_agent.py
â”‚   â”œâ”€â”€ legislative_agent.py
â”‚   â””â”€â”€ emergency_agent.py
â”‚
â”œâ”€â”€ analyzers/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ legal_text_analyzer.py
â”‚   â”œâ”€â”€ case_analyzer.py
â”‚   â”œâ”€â”€ statute_analyzer.py
â”‚   â”œâ”€â”€ contract_analyzer.py
â”‚   â”œâ”€â”€ regulatory_analyzer.py
â”‚   â”œâ”€â”€ sentiment_analyzer.py
â”‚   â”œâ”€â”€ risk_analyzer.py
â”‚   â”œâ”€â”€ compliance_analyzer.py
â”‚   â”œâ”€â”€ pattern_analyzer.py
â”‚   â”œâ”€â”€ anomaly_analyzer.py
â”‚   â”œâ”€â”€ budget_analyzer.py
â”‚   â”œâ”€â”€ timeline_analyzer.py
â”‚   â””â”€â”€ network_analyzer.py
â”‚
â”œâ”€â”€ database/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ connection.py
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ case_model.py
â”‚   â”‚   â”œâ”€â”€ statute_model.py
â”‚   â”‚   â”œâ”€â”€ regulation_model.py
â”‚   â”‚   â”œâ”€â”€ agency_model.py
â”‚   â”‚   â”œâ”€â”€ audit_model.py
â”‚   â”‚   â”œâ”€â”€ alert_model.py
â”‚   â”‚   â”œâ”€â”€ document_model.py
â”‚   â”‚   â”œâ”€â”€ user_model.py
â”‚   â”‚   â””â”€â”€ api_log_model.py
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base_repository.py
â”‚   â”‚   â”œâ”€â”€ case_repository.py
â”‚   â”‚   â”œâ”€â”€ statute_repository.py
â”‚   â”‚   â”œâ”€â”€ regulation_repository.py
â”‚   â”‚   â””â”€â”€ audit_repository.py
â”‚   â””â”€â”€ migrations/
â”‚       â””â”€â”€ versions/
â”‚
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ app.py
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ cases.py
â”‚   â”‚   â”œâ”€â”€ statutes.py
â”‚   â”‚   â”œâ”€â”€ regulations.py
â”‚   â”‚   â”œâ”€â”€ agencies.py
â”‚   â”‚   â”œâ”€â”€ audits.py
â”‚   â”‚   â”œâ”€â”€ alerts.py
â”‚   â”‚   â”œâ”€â”€ reports.py
â”‚   â”‚   â”œâ”€â”€ search.py
â”‚   â”‚   â”œâ”€â”€ watchdog.py
â”‚   â”‚   â””â”€â”€ admin.py
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py
â”‚   â”‚   â”œâ”€â”€ rate_limiter.py
â”‚   â”‚   â”œâ”€â”€ logging.py
â”‚   â”‚   â””â”€â”€ validation.py
â”‚   â””â”€â”€ schemas/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ request_schemas.py
â”‚       â””â”€â”€ response_schemas.py
â”‚
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ government_api_service.py
â”‚   â”œâ”€â”€ legal_database_service.py
â”‚   â”œâ”€â”€ notification_service.py
â”‚   â”œâ”€â”€ reporting_service.py
â”‚   â”œâ”€â”€ search_service.py
â”‚   â”œâ”€â”€ authentication_service.py
â”‚   â”œâ”€â”€ encryption_service.py
â”‚   â””â”€â”€ external_api_service.py
â”‚
â”œâ”€â”€ algorithms/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ legal_reasoning.py
â”‚   â”œâ”€â”€ precedent_matching.py
â”‚   â”œâ”€â”€ compliance_scoring.py
â”‚   â”œâ”€â”€ risk_assessment.py
â”‚   â”œâ”€â”€ anomaly_detection.py
â”‚   â”œâ”€â”€ text_classification.py
â”‚   â”œâ”€â”€ entity_extraction.py
â”‚   â”œâ”€â”€ relationship_mapping.py
â”‚   â”œâ”€â”€ timeline_reconstruction.py
â”‚   â”œâ”€â”€ budget_analysis.py
â”‚   â”œâ”€â”€ network_analysis.py
â”‚   â””â”€â”€ predictive_models.py
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ access_control.py
â”‚   â”œâ”€â”€ audit_trail.py
â”‚   â”œâ”€â”€ encryption.py
â”‚   â”œâ”€â”€ data_classification.py
â”‚   â”œâ”€â”€ threat_detection.py
â”‚   â””â”€â”€ compliance_verification.py
â”‚
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ health_check.py
â”‚   â”œâ”€â”€ metrics.py
â”‚   â”œâ”€â”€ alerting.py
â”‚   â”œâ”€â”€ logging_config.py
â”‚   â””â”€â”€ dashboard.py
â”‚
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ helpers.py
â”‚   â”œâ”€â”€ validators.py
â”‚   â”œâ”€â”€ formatters.py
â”‚   â”œâ”€â”€ parsers.py
â”‚   â”œâ”€â”€ date_utils.py
â”‚   â””â”€â”€ text_utils.py
â”‚
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â”œâ”€â”€ test_agents/
â”‚   â”œâ”€â”€ test_analyzers/
â”‚   â”œâ”€â”€ test_algorithms/
â”‚   â”œâ”€â”€ test_api/
â”‚   â””â”€â”€ test_integration/
â”‚
â””â”€â”€ docs/
    â”œâ”€â”€ architecture.md
    â”œâ”€â”€ api_reference.md
    â”œâ”€â”€ deployment.md
    â”œâ”€â”€ agents.md
    â””â”€â”€ algorithms.md
```

---

## ðŸ“„ FILE 1: requirements.txt

```txt
# JAIPI-JUDICIAL V4 Requirements
# Core Framework
fastapi==0.109.0
uvicorn[standard]==0.27.0
pydantic==2.5.3
pydantic-settings==2.1.0

# Async Support
asyncio==3.4.3
aiohttp==3.9.1
aiofiles==23.2.1
httpx==0.26.0

# Database
sqlalchemy==2.0.25
asyncpg==0.29.0
alembic==1.13.1
redis==5.0.1
aioredis==2.0.1

# AI/ML
openai==1.9.0
anthropic==0.14.0
langchain==0.1.0
langchain-community==0.0.13
transformers==4.36.2
torch==2.1.2
sentence-transformers==2.2.2
spacy==3.7.2
nltk==3.8.1
scikit-learn==1.4.0
numpy==1.26.3
pandas==2.1.4

# Vector Database
chromadb==0.4.22
pinecone-client==3.0.0
faiss-cpu==1.7.4

# Document Processing
pypdf2==3.0.1
python-docx==1.1.0
beautifulsoup4==4.12.3
lxml==5.1.0
pdfplumber==0.10.3

# Security
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
cryptography==41.0.7
python-multipart==0.0.6

# Monitoring & Logging
prometheus-client==0.19.0
structlog==24.1.0
sentry-sdk==1.39.1
opentelemetry-api==1.22.0
opentelemetry-sdk==1.22.0

# Task Queue
celery==5.3.6
kombu==5.3.4

# Testing
pytest==7.4.4
pytest-asyncio==0.23.3
pytest-cov==4.1.0
httpx==0.26.0
faker==22.2.0

# Utilities
python-dotenv==1.0.0
tenacity==8.2.3
cachetools==5.3.2
python-dateutil==2.8.2
pytz==2024.1
orjson==3.9.12
msgpack==1.0.7

# Government API Clients
zeep==4.2.1  # SOAP client
xmltodict==0.13.0
requests==2.31.0

# Data Validation
cerberus==1.3.5
jsonschema==4.21.0

# Rate Limiting
slowapi==0.1.9
limits==3.7.0

# GraphQL (optional)
strawberry-graphql==0.217.1

# CLI
typer==0.9.0
rich==13.7.0
```

---

## ðŸ“„ FILE 2: setup.py

```python
#!/usr/bin/env python3
"""
JAIPI-JUDICIAL V4 Setup Configuration
Government API & Law Watchdog System
"""

from setuptools import setup, find_packages
from pathlib import Path

# Read README
this_directory = Path(__file__).parent
long_description = (this_directory / "README.md").read_text(encoding="utf-8")

# Read requirements
requirements = (this_directory / "requirements.txt").read_text().splitlines()
requirements = [r.strip() for r in requirements if r.strip() and not r.startswith("#")]

setup(
    name="jaipi-judicial-v4",
    version="4.0.0",
    author="JAIPI Development Team",
    author_email="dev@jaipi-judicial.gov",
    description="Judicial AI Processing Interface - Government API & Law Watchdog System",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/Jblzy/JAIPI-JUDICIAL",
    project_urls={
        "Bug Tracker": "https://github.com/Jblzy/JAIPI-JUDICIAL/issues",
        "Documentation": "https://jaipi-judicial.readthedocs.io/",
        "Source Code": "https://github.com/Jblzy/JAIPI-JUDICIAL",
    },
    packages=find_packages(exclude=["tests", "tests.*", "docs"]),
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Legal Industry",
        "Intended Audience :: Government",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Topic :: Scientific/Engineering :: Artificial Intelligence",
        "Topic :: Legal",
        "Topic :: Government",
        "Framework :: FastAPI",
    ],
    python_requires=">=3.10",
    install_requires=requirements,
    extras_require={
        "dev": [
            "black>=23.12.0",
            "isort>=5.13.0",
            "flake8>=7.0.0",
            "mypy>=1.8.0",
            "pre-commit>=3.6.0",
        ],
        "docs": [
            "sphinx>=7.2.0",
            "sphinx-rtd-theme>=2.0.0",
            "myst-parser>=2.0.0",
        ],
        "gpu": [
            "torch[cuda]>=2.1.2",
            "faiss-gpu>=1.7.4",
        ],
    },
    entry_points={
        "console_scripts": [
            "jaipi=cli.main:app",
            "jaipi-server=api.app:run_server",
            "jaipi-worker=core.worker:main",
        ],
    },
    include_package_data=True,
    package_data={
        "config": ["*.yaml", "*.json"],
        "templates": ["*.html", "*.jinja2"],
    },
    zip_safe=False,
)
```

---

## ðŸ“„ FILE 3: config/__init__.py

```python
"""
JAIPI-JUDICIAL V4 Configuration Package
Central configuration management for the entire system
"""

from .settings import Settings, get_settings
from .constants import (
    SystemConstants,
    LegalConstants,
    AgentConstants,
    SecurityConstants,
    APIConstants,
)
from .api_endpoints import GovernmentAPIEndpoints
from .jurisdictions import JurisdictionRegistry
from .legal_codes import LegalCodeRegistry
from .agency_registry import AgencyRegistry
from .compliance_rules import ComplianceRuleEngine
from .security_config import SecurityConfiguration

__all__ = [
    "Settings",
    "get_settings",
    "SystemConstants",
    "LegalConstants",
    "AgentConstants",
    "SecurityConstants",
    "APIConstants",
    "GovernmentAPIEndpoints",
    "JurisdictionRegistry",
    "LegalCodeRegistry",
    "AgencyRegistry",
    "ComplianceRuleEngine",
    "SecurityConfiguration",
]

# Version info
__version__ = "4.0.0"
__author__ = "JAIPI Development Team"
```

---

## ðŸ“„ FILE 4: config/settings.py

```python
"""
JAIPI-JUDICIAL V4 Settings Configuration
Comprehensive settings management with environment variable support
"""

from functools import lru_cache
from typing import Optional, List, Dict, Any
from pydantic import Field, SecretStr, validator, AnyHttpUrl
from pydantic_settings import BaseSettings, SettingsConfigDict
from enum import Enum
import os


class Environment(str, Enum):
    """Deployment environment types"""
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION = "production"
    TESTING = "testing"


class LogLevel(str, Enum):
    """Logging levels"""
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"


class DatabaseSettings(BaseSettings):
    """Database configuration"""
    model_config = SettingsConfigDict(env_prefix="DB_")
    
    host: str = Field(default="localhost", description="Database host")
    port: int = Field(default=5432, description="Database port")
    name: str = Field(default="jaipi_judicial", description="Database name")
    user: str = Field(default="jaipi", description="Database user")
    password: SecretStr = Field(default="", description="Database password")
    pool_size: int = Field(default=20, description="Connection pool size")
    max_overflow: int = Field(default=10, description="Max overflow connections")
    echo: bool = Field(default=False, description="Echo SQL statements")
    
    @property
    def async_url(self) -> str:
        """Async database URL"""
        return f"postgresql+asyncpg://{self.user}:{self.password.get_secret_value()}@{self.host}:{self.port}/{self.name}"
    
    @property
    def sync_url(self) -> str:
        """Sync database URL"""
        return f"postgresql://{self.user}:{self.password.get_secret_value()}@{self.host}:{self.port}/{self.name}"


class RedisSettings(BaseSettings):
    """Redis configuration"""
    model_config = SettingsConfigDict(env_prefix="REDIS_")
    
    host: str = Field(default="localhost")
    port: int = Field(default=6379)
    db: int = Field(default=0)
    password: Optional[SecretStr] = None
    ssl: bool = Field(default=False)
    max_connections: int = Field(default=100)
    
    @property
    def url(self) -> str:
        """Redis URL"""
        auth = f":{self.password.get_secret_value()}@" if self.password else ""
        protocol = "rediss" if self.ssl else "redis"
        return f"{protocol}://{auth}{self.host}:{self.port}/{self.db}"


class AIModelSettings(BaseSettings):
    """AI Model configuration"""
    model_config = SettingsConfigDict(env_prefix="AI_")
    
    openai_api_key: Optional[SecretStr] = None
    anthropic_api_key: Optional[SecretStr] = None
    
    # Model selections
    primary_llm: str = Field(default="gpt-4-turbo-preview")
    secondary_llm: str = Field(default="claude-3-opus-20240229")
    embedding_model: str = Field(default="text-embedding-3-large")
    
    # Model parameters
    temperature: float = Field(default=0.1, ge=0.0, le=2.0)
    max_tokens: int = Field(default=4096)
    timeout: int = Field(default=120)
    
    # Rate limiting
    requests_per_minute: int = Field(default=60)
    tokens_per_minute: int = Field(default=100000)


class VectorDBSettings(BaseSettings):
    """Vector database configuration"""
    model_config = SettingsConfigDict(env_prefix="VECTOR_")
    
    provider: str = Field(default="chromadb")  # chromadb, pinecone, faiss
    collection_name: str = Field(default="jaipi_legal_docs")
    
    # ChromaDB settings
    chroma_host: str = Field(default="localhost")
    chroma_port: int = Field(default=8000)
    
    # Pinecone settings
    pinecone_api_key: Optional[SecretStr] = None
    pinecone_environment: str = Field(default="us-west1-gcp")
    pinecone_index: str = Field(default="jaipi-legal")
    
    # Embedding dimensions
    embedding_dimensions: int = Field(default=3072)


class SecuritySettings(BaseSettings):
    """Security configuration"""
    model_config = SettingsConfigDict(env_prefix="SECURITY_")
    
    secret_key: SecretStr = Field(default="change-me-in-production")
    algorithm: str = Field(default="HS256")
    access_token_expire_minutes: int = Field(default=30)
    refresh_token_expire_days: int = Field(default=7)
    
    # Encryption
    encryption_key: Optional[SecretStr] = None
    
    # CORS
    cors_origins: List[str] = Field(default=["*"])
    cors_allow_credentials: bool = Field(default=True)
    
    # Rate limiting
    rate_limit_requests: int = Field(default=100)
    rate_limit_period: int = Field(default=60)  # seconds
    
    # API Keys
    require_api_key: bool = Field(default=True)
    api_key_header: str = Field(default="X-API-Key")


class GovernmentAPISettings(BaseSettings):
    """Government API integration settings"""
    model_config = SettingsConfigDict(env_prefix="GOV_API_")
    
    # Federal APIs
    regulations_gov_api_key: Optional[SecretStr] = None
    congress_gov_api_key: Optional[SecretStr] = None
    federal_register_api_key: Optional[SecretStr] = None
    pacer_username: Optional[str] = None
    pacer_password: Optional[SecretStr] = None
    
    # State APIs
    state_legislature_api_keys: Dict[str, SecretStr] = Field(default_factory=dict)
    
    # API Rate Limits
    default_rate_limit: int = Field(default=1000)  # requests per hour
    
    # Retry configuration
    max_retries: int = Field(default=3)
    retry_delay: float = Field(default=1.0)
    
    # Timeout
    request_timeout: int = Field(default=30)


class AgentSettings(BaseSettings):
    """Agent configuration"""
    model_config = SettingsConfigDict(env_prefix="AGENT_")
    
    # Agent pool settings
    max_concurrent_agents: int = Field(default=50)
    agent_timeout: int = Field(default=300)  # 5 minutes
    
    # Task queue settings
    task_queue_size: int = Field(default=1000)
    priority_levels: int = Field(default=5)
    
    # Agent-specific settings
    watchdog_interval: int = Field(default=60)  # seconds
    compliance_check_depth: int = Field(default=3)
    citation_max_depth: int = Field(default=5)
    precedent_similarity_threshold: float = Field(default=0.85)
    
    # Resource limits
    max_memory_per_agent_mb: int = Field(default=512)
    max_cpu_percent: float = Field(default=25.0)


class MonitoringSettings(BaseSettings):
    """Monitoring and observability settings"""
    model_config = SettingsConfigDict(env_prefix="MONITOR_")
    
    # Prometheus
    prometheus_enabled: bool = Field(default=True)
    prometheus_port: int = Field(default=9090)
    
    # Sentry
    sentry_dsn: Optional[str] = None
    sentry_traces_sample_rate: float = Field(default=0.1)
    
    # Health check
    health_check_interval: int = Field(default=30)
    
    # Alerting
    alert_email_enabled: bool = Field(default=False)
    alert_slack_webhook: Optional[str] = None
    alert_pagerduty_key: Optional[str] = None


class Settings(BaseSettings):
    """
    Master settings configuration
    Aggregates all sub-configurations
    """
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
        extra="allow",
    )
    
    # Application metadata
    app_name: str = Field(default="JAIPI-JUDICIAL V4")
    app_version: str = Field(default="4.0.0")
    app_description: str = Field(
        default="Judicial AI Processing Interface - Government API & Law Watchdog System"
    )
    
    # Environment
    environment: Environment = Field(default=Environment.DEVELOPMENT)
    debug: bool = Field(default=False)
    log_level: LogLevel = Field(default=LogLevel.INFO)
    
    # Server
    host: str = Field(default="0.0.0.0")
    port: int = Field(default=8000)
    workers: int = Field(default=4)
    
    # Sub-configurations
    database: DatabaseSettings = Field(default_factory=DatabaseSettings)
    redis: RedisSettings = Field(default_factory=RedisSettings)
    ai_model: AIModelSettings = Field(default_factory=AIModelSettings)
    vector_db: VectorDBSettings = Field(default_factory=VectorDBSettings)
    security: SecuritySettings = Field(default_factory=SecuritySettings)
    government_api: GovernmentAPISettings = Field(default_factory=GovernmentAPISettings)
    agent: AgentSettings = Field(default_factory=AgentSettings)
    monitoring: MonitoringSettings = Field(default_factory=MonitoringSettings)
    
    @validator("environment", pre=True)
    def validate_environment(cls, v):
        if isinstance(v, str):
            return Environment(v.lower())
        return v
    
    @property
    def is_production(self) -> bool:
        return self.environment == Environment.PRODUCTION
    
    @property
    def is_development(self) -> bool:
        return self.environment == Environment.DEVELOPMENT


@lru_cache()
def get_settings() -> Settings:
    """
    Get cached settings instance
    Uses LRU cache to prevent repeated env parsing
    """
    return Settings()


# Convenience access
settings = get_settings()
```

---

## ðŸ“„ FILE 5: config/constants.py

```python
"""
JAIPI-JUDICIAL V4 System Constants
Immutable configuration values used throughout the system
"""

from enum import Enum, auto
from typing import Dict, List, Set, FrozenSet
from dataclasses import dataclass, field


class SystemConstants:
    """Core system constants"""
    
    # Version information
    VERSION = "4.0.0"
    API_VERSION = "v4"
    BUILD_DATE = "2026-01-01"
    
    # System limits
    MAX_BATCH_SIZE = 1000
    MAX_QUERY_RESULTS = 10000
    MAX_FILE_SIZE_MB = 100
    MAX_CONCURRENT_REQUESTS = 500
    
    # Timeouts (seconds)
    DEFAULT_TIMEOUT = 30
    LONG_TIMEOUT = 300
    AGENT_TIMEOUT = 600
    
    # Pagination
    DEFAULT_PAGE_SIZE = 50
    MAX_PAGE_SIZE = 500
    
    # Cache TTL (seconds)
    CACHE_TTL_SHORT = 300  # 5 minutes
    CACHE_TTL_MEDIUM = 3600  # 1 hour
    CACHE_TTL_LONG = 86400  # 24 hours
    CACHE_TTL_EXTENDED = 604800  # 7 days


class LegalConstants:
    """Legal domain constants"""
    
    # Court levels
    COURT_LEVELS = {
        "SUPREME": 1,
        "APPELLATE": 2,
        "DISTRICT": 3,
        "BANKRUPTCY": 4,
        "MAGISTRATE": 5,
        "STATE_SUPREME": 6,
        "STATE_APPELLATE": 7,
        "STATE_TRIAL": 8,
        "ADMINISTRATIVE": 9,
        "TRIBAL": 10,
    }
    
    # Legal document types
    DOCUMENT_TYPES = frozenset({
        "opinion",
        "order",
        "ruling",
        "judgment",
        "decree",
        "motion",
        "brief",
        "complaint",
        "answer",
        "petition",
        "memorandum",
        "stipulation",
        "affidavit",
        "declaration",
        "subpoena",
        "warrant",
        "indictment",
        "statute",
        "regulation",
        "rule",
        "executive_order",
        "proclamation",
        "treaty",
        "contract",
        "settlement",
    })
    
    # Case status values
    CASE_STATUS = frozenset({
        "pending",
        "active",
        "stayed",
        "dismissed",
        "settled",
        "judgment_entered",
        "appealed",
        "remanded",
        "closed",
        "archived",
    })
    
    # Legal practice areas
    PRACTICE_AREAS = frozenset({
        "constitutional",
        "administrative",
        "criminal",
        "civil",
        "corporate",
        "environmental",
        "immigration",
        "intellectual_property",
        "labor_employment",
        "tax",
        "bankruptcy",
        "family",
        "real_estate",
        "securities",
        "antitrust",
        "healthcare",
        "education",
        "civil_rights",
        "government_contracts",
        "international",
    })
    
    # Citation formats
    CITATION_PATTERNS = {
        "us_reporter": r"(\d+)\s+U\.S\.\s+(\d+)",
        "supreme_court_reporter": r"(\d+)\s+S\.\s*Ct\.\s+(\d+)",
        "federal_reporter": r"(\d+)\s+F\.(2d|3d|4th)?\s+(\d+)",
        "federal_supplement": r"(\d+)\s+F\.\s*Supp\.(2d|3d)?\s+(\d+)",
        "usc": r"(\d+)\s+U\.S\.C\.\s+Â§?\s*(\d+)",
        "cfr": r"(\d+)\s+C\.F\.R\.\s+Â§?\s*([\d\.]+)",
        "federal_register": r"(\d+)\s+Fed\.\s*Reg\.\s+(\d+)",
        "public_law": r"Pub\.\s*L\.\s*No\.\s*(\d+)-(\d+)",
        "state_reporter": r"(\d+)\s+([A-Z][a-z]+\.?)\s*(2d|3d)?\s+(\d+)",
    }
    
    # Statute of limitations (years) by case type
    STATUTE_OF_LIMITATIONS = {
        "breach_of_contract": 4,
        "fraud": 3,
        "personal_injury": 2,
        "medical_malpractice": 2,
        "defamation": 1,
        "employment_discrimination": 0.5,  # 180 days
        "civil_rights": 2,
        "environmental": 5,
        "securities_fraud": 5,
        "tax_evasion": 6,
        "federal_criminal": 5,
        "state_criminal_felony": 6,
        "state_criminal_misdemeanor": 2,
    }


class AgentConstants:
    """Agent-related constants"""
    
    # Agent types
    class AgentType(Enum):
        WATCHDOG = auto()
        COMPLIANCE = auto()
        CITATION = auto()
        PRECEDENT = auto()
        STATUTORY = auto()
        CONSTITUTIONAL = auto()
        REGULATORY = auto()
        PROCEDURAL = auto()
        EVIDENCE = auto()
        SENTIMENT = auto()
        RISK = auto()
        AUDIT = auto()
        NOTIFICATION = auto()
        COORDINATION = auto()
        FOIA = auto()
        ETHICS = auto()
        JURISDICTION = auto()
        TIMELINE = auto()
        DOCUMENT = auto()
        API_MONITOR = auto()
        BUDGET = auto()
        TRANSPARENCY = auto()
        WHISTLEBLOWER = auto()
        CONTRACT = auto()
        ADMINISTRATIVE = auto()
        ENFORCEMENT = auto()
        APPEALS = auto()
        LEGISLATIVE = auto()
        EMERGENCY = auto()
    
    # Agent priorities
    class Priority(Enum):
        CRITICAL = 1
        HIGH = 2
        MEDIUM = 3
        LOW = 4
        BACKGROUND = 5
    
    # Agent states
    class AgentState(Enum):
        INITIALIZING = auto()
        IDLE = auto()
        PROCESSING = auto()
        WAITING = auto()
        SUSPENDED = auto()
        ERROR = auto()
        TERMINATED = auto()
    
    # Default agent configurations
    DEFAULT_CONFIGS = {
        "max_retries": 3,
        "retry_delay": 1.0,
        "timeout": 300,
        "batch_size": 100,
        "priority": 3,
    }
    
    # Agent resource limits
    RESOURCE_LIMITS = {
        "max_memory_mb": 512,
        "max_cpu_percent": 25,
        "max_concurrent_tasks": 10,
        "max_queue_size": 1000,
    }


class SecurityConstants:
    """Security-related constants"""
    
    # Classification levels
    class Classification(Enum):
        PUBLIC = 1
        INTERNAL = 2
        CONFIDENTIAL = 3
        RESTRICTED = 4
        TOP_SECRET = 5
    
    # Permission types
    class Permission(Enum):
        READ = auto()
        WRITE = auto()
        DELETE = auto()
        ADMIN = auto()
        AUDIT = auto()
        EXPORT = auto()
        API_ACCESS = auto()
    
    # Role definitions
    ROLES = {
        "public": {Permission.READ},
        "analyst": {Permission.READ, Permission.WRITE},
        "auditor": {Permission.READ, Permission.AUDIT},
        "admin": {Permission.READ, Permission.WRITE, Permission.DELETE, Permission.ADMIN},
        "superadmin": set(Permission),
    }
    
    # Password requirements
    PASSWORD_MIN_LENGTH = 12
    PASSWORD_REQUIRE_UPPERCASE = True
    PASSWORD_REQUIRE_LOWERCASE = True
    PASSWORD_REQUIRE_DIGIT = True
    PASSWORD_REQUIRE_SPECIAL = True
    
    # Session settings
    SESSION_TIMEOUT_MINUTES = 30
    MAX_SESSIONS_PER_USER = 5
    
    # Rate limiting defaults
    RATE_LIMIT_DEFAULT = 100  # requests per minute
    RATE_LIMIT_BURST = 20  # burst allowance


class APIConstants:
    """API-related constants"""
    
    # HTTP status codes with meanings
    STATUS_CODES = {
        200: "OK",
        201: "Created",
        202: "Accepted",
        204: "No Content",
        400: "Bad Request",
        401: "Unauthorized",
        403: "Forbidden",
        404: "Not Found",
        409: "Conflict",
        422: "Unprocessable Entity",
        429: "Too Many Requests",
        500: "Internal Server Error",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
    }
    
    # API versioning
    SUPPORTED_VERSIONS = ["v4", "v3"]
    CURRENT_VERSION = "v4"
    DEPRECATED_VERSIONS = ["v1", "v2"]
    
    # Content types
    CONTENT_TYPES = {
        "json": "application/json",
        "xml": "application/xml",
        "pdf": "application/pdf",
        "html": "text/html",
        "text": "text/plain",
        "csv": "text/csv",
    }
    
    # API headers
    REQUIRED_HEADERS = {
        "X-API-Key",
        "X-Request-ID",
    }
    
    OPTIONAL_HEADERS = {
        "X-Correlation-ID",
        "X-Client-Version",
        "X-Jurisdiction",
    }


@dataclass(frozen=True)
class ComplianceConstants:
    """Compliance-related constants"""
    
    # Compliance frameworks
    FRAMEWORKS: FrozenSet[str] = frozenset({
        "APA",  # Administrative Procedure Act
        "FOIA",  # Freedom of Information Act
        "FACA",  # Federal Advisory Committee Act
        "PRA",  # Paperwork Reduction Act
        "DATA_ACT",  # Digital Accountability and Transparency Act
        "FITARA",  # Federal IT Acquisition Reform Act
        "FISMA",  # Federal Information Security Management Act
        "HIPAA",  # Health Insurance Portability and Accountability Act
        "FERPA",  # Family Educational Rights and Privacy Act
        "ECPA",  # Electronic Communications Privacy Act
        "CFAA",  # Computer Fraud and Abuse Act
        "ADA",  # Americans with Disabilities Act
        "SECTION_508",  # Accessibility requirements
        "FRA",  # Federal Records Act
        "EO_12866",  # Executive Order on Regulatory Planning
        "GPRA",  # Government Performance and Results Act
    })
    
    # Compliance status values
    STATUS_VALUES: FrozenSet[str] = frozenset({
        "compliant",
        "non_compliant",
        "partial",
        "pending_review",
        "waiver_granted",
        "not_applicable",
        "under_investigation",
    })
    
    # Severity levels for violations
    SEVERITY_LEVELS: Dict[str, int] = field(default_factory=lambda: {
        "critical": 1,
        "high": 2,
        "medium": 3,
        "low": 4,
        "informational": 5,
    })


# Export all constants
__all__ = [
    "SystemConstants",
    "LegalConstants",
    "AgentConstants",
    "SecurityConstants",
    "APIConstants",
    "ComplianceConstants",
]
```

---

## ðŸ“„ FILE 6: config/api_endpoints.py

```python
"""
JAIPI-JUDICIAL V4 Government API Endpoints Registry
Comprehensive catalog of federal, state, and local government APIs
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from enum import Enum


class APICategory(Enum):
    """Categories of government APIs"""
    LEGISLATIVE = "legislative"
    JUDICIAL = "judicial"
    EXECUTIVE = "executive"
    REGULATORY = "regulatory"
    FINANCIAL = "financial"
    PROCUREMENT = "procurement"
    RECORDS = "records"
    DATA = "data"
    TRANSPARENCY = "transparency"


class AuthMethod(Enum):
    """Authentication methods for APIs"""
    NONE = "none"
    API_KEY = "api_key"
    OAUTH2 = "oauth2"
    BASIC = "basic"
    CERTIFICATE = "certificate"
    SAML = "saml"


@dataclass
class APIEndpoint:
    """Represents a single API endpoint"""
    name: str
    url: str
    category: APICategory
    auth_method: AuthMethod
    rate_limit: int  # requests per hour
    description: str
    documentation_url: Optional[str] = None
    version: str = "1.0"
    active: bool = True
    requires_registration: bool = False
    data_format: str = "json"
    additional_headers: Dict[str, str] = field(default_factory=dict)


@dataclass
class GovernmentAPIEndpoints:
    """
    Central registry of all government API endpoints
    Used by agents for data collection and monitoring
    """
    
    # =================================================================
    # FEDERAL LEGISLATIVE APIs
    # =================================================================
    
    CONGRESS_GOV = APIEndpoint(
        name="Congress.gov API",
        url="https://api.congress.gov/v3",
        category=APICategory.LEGISLATIVE,
        auth_method=AuthMethod.API_KEY,
        rate_limit=5000,
        description="Official Congress.gov API for bills, members, and legislative data",
        documentation_url="https://api.congress.gov/",
        version="3.0",
    )
    
    GOVINFO = APIEndpoint(
        name="GovInfo API",
        url="https://api.govinfo.gov",
        category=APICategory.LEGISLATIVE,
        auth_method=AuthMethod.API_KEY,
        rate_limit=1000,
        description="Government Publishing Office documents and publications",
        documentation_url="https://api.govinfo.gov/docs/",
        version="2.0",
    )
    
    BULK_DATA = APIEndpoint(
        name="Congress Bulk Data",
        url="https://www.govinfo.gov/bulkdata",
        category=APICategory.LEGISLATIVE,
        auth_method=AuthMethod.NONE,
        rate_limit=100,
        description="Bulk download of Congressional documents",
    )
    
    # =================================================================
    # FEDERAL JUDICIAL APIs
    # =================================================================
    
    PACER = APIEndpoint(
        name="PACER",
        url="https://pcl.uscourts.gov/pcl/",
        category=APICategory.JUDICIAL,
        auth_method=AuthMethod.BASIC,
        rate_limit=1000,
        description="Public Access to Court Electronic Records",
        documentation_url="https://pacer.uscourts.gov/",
        requires_registration=True,
    )
    
    RECAP = APIEndpoint(
        name="RECAP Archive",
        url="https://www.courtlistener.com/api/rest/v3/",
        category=APICategory.JUDICIAL,
        auth_method=AuthMethod.API_KEY,
        rate_limit=5000,
        description="Free Law Project RECAP Archive API",
        documentation_url="https://www.courtlistener.com/api/",
    )
    
    SUPREME_COURT = APIEndpoint(
        name="Supreme Court API",
        url="https://api.oyez.org",
        category=APICategory.JUDICIAL,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="Oyez Project Supreme Court data",
    )
    
    FEDERAL_COURTS = APIEndpoint(
        name="Federal Courts Statistics",
        url="https://www.uscourts.gov/statistics-reports",
        category=APICategory.JUDICIAL,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="Federal court statistics and caseload data",
    )
    
    # =================================================================
    # FEDERAL REGULATORY APIs
    # =================================================================
    
    REGULATIONS_GOV = APIEndpoint(
        name="Regulations.gov API",
        url="https://api.regulations.gov/v4",
        category=APICategory.REGULATORY,
        auth_method=AuthMethod.API_KEY,
        rate_limit=1000,
        description="Federal rulemaking and public comments",
        documentation_url="https://open.gsa.gov/api/regulationsgov/",
        version="4.0",
    )
    
    FEDERAL_REGISTER = APIEndpoint(
        name="Federal Register API",
        url="https://www.federalregister.gov/api/v1",
        category=APICategory.REGULATORY,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="Daily journal of the US Government",
        documentation_url="https://www.federalregister.gov/developers/documentation/api/v1",
    )
    
    ECFR = APIEndpoint(
        name="eCFR API",
        url="https://www.ecfr.gov/api/versioner/v1",
        category=APICategory.REGULATORY,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="Electronic Code of Federal Regulations",
        documentation_url="https://www.ecfr.gov/developer-resources",
    )
    
    # =================================================================
    # FEDERAL FINANCIAL APIs
    # =================================================================
    
    USASPENDING = APIEndpoint(
        name="USAspending API",
        url="https://api.usaspending.gov/api/v2",
        category=APICategory.FINANCIAL,
        auth_method=AuthMethod.NONE,
        rate_limit=2000,
        description="Federal spending data and awards",
        documentation_url="https://api.usaspending.gov/docs/",
        version="2.0",
    )
    
    FISCAL_DATA = APIEndpoint(
        name="Fiscal Data API",
        url="https://api.fiscaldata.treasury.gov/services/api/fiscal_service",
        category=APICategory.FINANCIAL,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="Treasury fiscal data and debt information",
        documentation_url="https://fiscaldata.treasury.gov/api-documentation/",
    )
    
    SAM_GOV = APIEndpoint(
        name="SAM.gov Entity API",
        url="https://api.sam.gov/entity-information/v3",
        category=APICategory.PROCUREMENT,
        auth_method=AuthMethod.API_KEY,
        rate_limit=1000,
        description="System for Award Management entity data",
        documentation_url="https://open.gsa.gov/api/entity-api/",
        version="3.0",
    )
    
    FPDS = APIEndpoint(
        name="FPDS API",
        url="https://www.fpds.gov/ezsearch/FEEDS/ATOM",
        category=APICategory.PROCUREMENT,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="Federal Procurement Data System",
        data_format="atom",
    )
    
    # =================================================================
    # FEDERAL TRANSPARENCY APIs
    # =================================================================
    
    FOIA_GOV = APIEndpoint(
        name="FOIA.gov API",
        url="https://api.foia.gov/api",
        category=APICategory.TRANSPARENCY,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="FOIA request and report data",
    )
    
    DATA_GOV = APIEndpoint(
        name="Data.gov CKAN API",
        url="https://catalog.data.gov/api/3",
        category=APICategory.DATA,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="Federal open data catalog",
        documentation_url="https://data.gov/developers/",
    )
    
    OPEN_SECRETS = APIEndpoint(
        name="OpenSecrets API",
        url="https://www.opensecrets.org/api",
        category=APICategory.TRANSPARENCY,
        auth_method=AuthMethod.API_KEY,
        rate_limit=200,
        description="Campaign finance and lobbying data",
        documentation_url="https://www.opensecrets.org/open-data/api",
    )
    
    FEC = APIEndpoint(
        name="FEC API",
        url="https://api.open.fec.gov/v1",
        category=APICategory.TRANSPARENCY,
        auth_method=AuthMethod.API_KEY,
        rate_limit=1000,
        description="Federal Election Commission data",
        documentation_url="https://api.open.fec.gov/developers/",
    )
    
    # =================================================================
    # EXECUTIVE BRANCH APIs
    # =================================================================
    
    WHITE_HOUSE = APIEndpoint(
        name="White House API",
        url="https://www.whitehouse.gov/wp-json/wp/v2",
        category=APICategory.EXECUTIVE,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="White House press releases and content",
    )
    
    EXECUTIVE_ORDERS = APIEndpoint(
        name="Executive Orders API",
        url="https://www.federalregister.gov/api/v1/documents",
        category=APICategory.EXECUTIVE,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="Presidential executive orders",
    )
    
    # =================================================================
    # AGENCY-SPECIFIC APIs
    # =================================================================
    
    SEC_EDGAR = APIEndpoint(
        name="SEC EDGAR API",
        url="https://data.sec.gov",
        category=APICategory.REGULATORY,
        auth_method=AuthMethod.NONE,
        rate_limit=10,  # Very restrictive
        description="SEC filings and company data",
        documentation_url="https://www.sec.gov/developer",
        additional_headers={"User-Agent": "JAIPI-JUDICIAL/4.0"},
    )
    
    EPA_ENVIROFACTS = APIEndpoint(
        name="EPA Envirofacts API",
        url="https://enviro.epa.gov/enviro/efservice",
        category=APICategory.REGULATORY,
        auth_method=AuthMethod.NONE,
        rate_limit=1000,
        description="EPA environmental data",
    )
    
    DOJ_API = APIEndpoint(
        name="DOJ Press Releases",
        url="https://www.justice.gov/api/v1",
        category=APICategory.EXECUTIVE,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="Department of Justice press releases",
    )
    
    IRS_SOI = APIEndpoint(
        name="IRS Statistics of Income",
        url="https://www.irs.gov/statistics",
        category=APICategory.FINANCIAL,
        auth_method=AuthMethod.NONE,
        rate_limit=100,
        description="IRS tax statistics data",
    )
    
    # =================================================================
    # STATE GOVERNMENT APIs (Examples)
    # =================================================================
    
    CA_LEGISLATURE = APIEndpoint(
        name="California Legislature API",
        url="https://leginfo.legislature.ca.gov/",
        category=APICategory.LEGISLATIVE,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="California legislative information",
    )
    
    NY_OPEN_LEGISLATION = APIEndpoint(
        name="NY Open Legislation API",
        url="https://legislation.nysenate.gov/api/3",
        category=APICategory.LEGISLATIVE,
        auth_method=AuthMethod.API_KEY,
        rate_limit=1000,
        description="New York State legislative data",
        documentation_url="https://legislation.nysenate.gov/docs",
        version="3.0",
    )
    
    TX_LEGISLATURE = APIEndpoint(
        name="Texas Legislature Online",
        url="https://capitol.texas.gov/",
        category=APICategory.LEGISLATIVE,
        auth_method=AuthMethod.NONE,
        rate_limit=500,
        description="Texas legislative information",
    )
    
    # =================================================================
    # METHODS
    # =================================================================
    
    @classmethod
    def get_all_endpoints(cls) -> List[APIEndpoint]:
        """Return all defined endpoints"""
        return [
            getattr(cls, attr) for attr in dir(cls)
            if isinstance(getattr(cls, attr), APIEndpoint)
        ]
    
    @classmethod
    def get_by_category(cls, category: APICategory) -> List[APIEndpoint]:
        """Get endpoints by category"""
        return [ep for ep in cls.get_all_endpoints() if ep.category == category]
    
    @classmethod
    def get_active_endpoints(cls) -> List[APIEndpoint]:
        """Get only active endpoints"""
        return [ep for ep in cls.get_all_endpoints() if ep.active]
    
    @classmethod
    def get_endpoint_by_name(cls, name: str) -> Optional[APIEndpoint]:
        """Get endpoint by name"""
        for ep in cls.get_all_endpoints():
            if ep.name.lower() == name.lower():
                return ep
        return None
    
    @classmethod
    def get_endpoints_requiring_auth(cls) -> List[APIEndpoint]:
        """Get endpoints that require authentication"""
        return [
            ep for ep in cls.get_all_endpoints() 
            if ep.auth_method != AuthMethod.NONE
        ]
    
    @classmethod
    def to_dict(cls) -> Dict[str, Any]:
        """Export all endpoints as dictionary"""
        return {
            ep.name: {
                "url": ep.url,
                "category": ep.category.value,
                "auth_method": ep.auth_method.value,
                "rate_limit": ep.rate_limit,
                "description": ep.description,
                "active": ep.active,
            }
            for ep in cls.get_all_endpoints()
        }
```

---

## ðŸ“„ FILE 7: config/jurisdictions.py

```python
"""
JAIPI-JUDICIAL V4 Jurisdiction Registry
Complete mapping of US federal and state jurisdictions
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
from enum import Enum


class JurisdictionType(Enum):
    """Types of jurisdictions"""
    FEDERAL = "federal"
    STATE = "state"
    TERRITORIAL = "territorial"
    TRIBAL = "tribal"
    LOCAL = "local"
    INTERNATIONAL = "international"


class CourtSystem(Enum):
    """Court system types"""
    ARTICLE_III = "article_iii"  # Federal constitutional courts
    ARTICLE_I = "article_i"  # Federal legislative courts
    STATE = "state"
    ADMINISTRATIVE = "administrative"
    MILITARY = "military"
    TRIBAL = "tribal"


@dataclass
class Court:
    """Represents a specific court"""
    name: str
    abbreviation: str
    level: int  # 1=highest, higher numbers = lower courts
    system: CourtSystem
    jurisdiction_type: JurisdictionType
    appeals_to: Optional[str] = None
    pacer_code: Optional[str] = None
    website: Optional[str] = None


@dataclass
class Jurisdiction:
    """Represents a complete jurisdiction"""
    name: str
    abbreviation: str
    type: JurisdictionType
    fips_code: Optional[str] = None
    courts: List[Court] = field(default_factory=list)
    statutes_url: Optional[str] = None
    regulations_url: Optional[str] = None
    legislature_url: Optional[str] = None


class JurisdictionRegistry:
    """
    Complete registry of US jurisdictions and courts
    Used for proper routing and jurisdiction analysis
    """
    
    # =================================================================
    # FEDERAL COURTS
    # =================================================================
    
    FEDERAL_COURTS = [
        Court(
            name="Supreme Court of the United States",
            abbreviation="SCOTUS",
            level=1,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            website="https://www.supremecourt.gov",
        ),
        Court(
            name="United States Court of Appeals for the First Circuit",
            abbreviation="1st Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca1",
        ),
        Court(
            name="United States Court of Appeals for the Second Circuit",
            abbreviation="2d Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca2",
        ),
        Court(
            name="United States Court of Appeals for the Third Circuit",
            abbreviation="3d Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca3",
        ),
        Court(
            name="United States Court of Appeals for the Fourth Circuit",
            abbreviation="4th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca4",
        ),
        Court(
            name="United States Court of Appeals for the Fifth Circuit",
            abbreviation="5th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca5",
        ),
        Court(
            name="United States Court of Appeals for the Sixth Circuit",
            abbreviation="6th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca6",
        ),
        Court(
            name="United States Court of Appeals for the Seventh Circuit",
            abbreviation="7th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca7",
        ),
        Court(
            name="United States Court of Appeals for the Eighth Circuit",
            abbreviation="8th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca8",
        ),
        Court(
            name="United States Court of Appeals for the Ninth Circuit",
            abbreviation="9th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca9",
        ),
        Court(
            name="United States Court of Appeals for the Tenth Circuit",
            abbreviation="10th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca10",
        ),
        Court(
            name="United States Court of Appeals for the Eleventh Circuit",
            abbreviation="11th Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="ca11",
        ),
        Court(
            name="United States Court of Appeals for the D.C. Circuit",
            abbreviation="D.C. Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="cadc",
        ),
        Court(
            name="United States Court of Appeals for the Federal Circuit",
            abbreviation="Fed. Cir.",
            level=2,
            system=CourtSystem.ARTICLE_III,
            jurisdiction_type=JurisdictionType.FEDERAL,
            appeals_to="SCOTUS",
            pacer_code="cafc",
        ),
    ]
    
    # =================================================================
    # STATE JURISDICTIONS
    # =================================================================
    
    STATES = {
        "AL": Jurisdiction(
            name="Alabama",
            abbreviation="AL",
            type=JurisdictionType.STATE,
            fips_code="01",
            statutes_url="http://alisondb.legislature.state.al.us/alison/CodeOfAlabama/1975/coatoc.htm",
            legislature_url="http://www.legislature.state.al.us/",
        ),
        "AK": Jurisdiction(
            name="Alaska",
            abbreviation="AK",
            type=JurisdictionType.STATE,
            fips_code="02",
            statutes_url="http://www.akleg.gov/basis/statutes.asp",
            legislature_url="http://www.akleg.gov/",
        ),
        "AZ": Jurisdiction(
            name="Arizona",
            abbreviation="AZ",
            type=JurisdictionType.STATE,
            fips_code="04",
            statutes_url="https://www.azleg.gov/arstitle/",
            legislature_url="https://www.azleg.gov/",
        ),
        "AR": Jurisdiction(
            name="Arkansas",
            abbreviation="AR",
            type=JurisdictionType.STATE,
            fips_code="05",
            statutes_url="https://www.lexisnexis.com/hottopics/arcode/",
            legislature_url="https://www.arkleg.state.ar.us/",
        ),
        "CA": Jurisdiction(
            name="California",
            abbreviation="CA",
            type=JurisdictionType.STATE,
            fips_code="06",
            statutes_url="https://leginfo.legislature.ca.gov/faces/codes.xhtml",
            regulations_url="https://govt.westlaw.com/calregs",
            legislature_url="https://legislature.ca.gov/",
        ),
        "CO": Jurisdiction(
            name="Colorado",
            abbreviation="CO",
            type=JurisdictionType.STATE,
            fips_code="08",
            statutes_url="https://leg.colorado.gov/colorado-revised-statutes",
            legislature_url="https://leg.colorado.gov/",
        ),
        "CT": Jurisdiction(
            name="Connecticut",
            abbreviation="CT",
            type=JurisdictionType.STATE,
            fips_code="09",
            statutes_url="https://www.cga.ct.gov/current/pub/titles.htm",
            legislature_url="https://www.cga.ct.gov/",
        ),
        "DE": Jurisdiction(
            name="Delaware",
            abbreviation="DE",
            type=JurisdictionType.STATE,
            fips_code="10",
            statutes_url="https://delcode.delaware.gov/",
            legislature_url="https://legis.delaware.gov/",
        ),
        "FL": Jurisdiction(
            name="Florida",
            abbreviation="FL",
            type=JurisdictionType.STATE,
            fips_code="12",
            statutes_url="http://www.leg.state.fl.us/statutes/",
            legislature_url="https://www.myfloridahouse.gov/",
        ),
        "GA": Jurisdiction(
            name="Georgia",
            abbreviation="GA",
            type=JurisdictionType.STATE,
            fips_code="13",
            statutes_url="https://www.legis.ga.gov/",
            legislature_url="https://www.legis.ga.gov/",
        ),
        "HI": Jurisdiction(
            name="Hawaii",
            abbreviation="HI",
            type=JurisdictionType.STATE,
            fips_code="15",
            statutes_url="https://www.capitol.hawaii.gov/hrs.aspx",
            legislature_url="https://www.capitol.hawaii.gov/",
        ),
        "ID": Jurisdiction(
            name="Idaho",
            abbreviation="ID",
            type=JurisdictionType.STATE,
            fips_code="16",
            statutes_url="https://legislature.idaho.gov/statutesrules/idstat/",
            legislature_url="https://legislature.idaho.gov/",
        ),
        "IL": Jurisdiction(
            name="Illinois",
            abbreviation="IL",
            type=JurisdictionType.STATE,
            fips_code="17",
            statutes_url="https://www.ilga.gov/legislation/ilcs/ilcs.asp",
            legislature_url="https://www.ilga.gov/",
        ),
        "IN": Jurisdiction(
            name="Indiana",
            abbreviation="IN",
            type=JurisdictionType.STATE,
            fips_code="18",
            statutes_url="http://iga.in.gov/legislative/laws/current/ic/",
            legislature_url="http://iga.in.gov/",
        ),
        "IA": Jurisdiction(
            name="Iowa",
            abbreviation="IA",
            type=JurisdictionType.STATE,
            fips_code="19",
            statutes_url="https://www.legis.iowa.gov/law/iowaCode",
            legislature_url="https://www.legis.iowa.gov/",
        ),
        "KS": Jurisdiction(
            name="Kansas",
            abbreviation="KS",
            type=JurisdictionType.STATE,
            fips_code="20",
            statutes_url="http://www.kslegislature.org/li/b2023_24/statute/",
            legislature_url="http://www.kslegislature.org/",
        ),
        "KY": Jurisdiction(
            name="Kentucky",
            abbreviation="KY",
            type=JurisdictionType.STATE,
            fips_code="21",
            statutes_url="https://apps.legislature.ky.gov/law/statutes/",
            legislature_url="https://legislature.ky.gov/",
        ),
        "LA": Jurisdiction(
            name="Louisiana",
            abbreviation="LA",
            type=JurisdictionType.STATE,
            fips_code="22",
            statutes_url="http://legis.la.gov/legis/LawSearch.aspx",
            legislature_url="http://legis.la.gov/",
        ),
        "ME": Jurisdiction(
            name="Maine",
            abbreviation="ME",
            type=JurisdictionType.STATE,
            fips_code="23",
            statutes_url="http://legislature.maine.gov/statutes/",
            legislature_url="http://legislature.maine.gov/",
        ),
        "MD": Jurisdiction(
            name="Maryland",
            abbreviation="MD",
            type=JurisdictionType.STATE,
            fips_code="24",
            statutes_url="https://mgaleg.maryland.gov/mgawebsite/Laws/Statutes",
            legislature_url="https://mgaleg.maryland.gov/",
        ),
        "MA": Jurisdiction(
            name="Massachusetts",
            abbreviation="MA",
            type=JurisdictionType.STATE,
            fips_code="25",
            statutes_url="https://malegislature.gov/Laws/GeneralLaws",
            legislature_url="https://malegislature.gov/",
        ),
        "MI": Jurisdiction(
            name="Michigan",
            abbreviation="MI",
            type=JurisdictionType.STATE,
            fips_code="26",
            statutes_url="http://legislature.mi.gov/doc.aspx?mcl-Act-Index",
            legislature_url="http://legislature.mi.gov/",
        ),
        "MN": Jurisdiction(
            name="Minnesota",
            abbreviation="MN",
            type=JurisdictionType.STATE,
            fips_code="27",
            statutes_url="https://www.revisor.mn.gov/statutes/",
            legislature_url="https://www.leg.mn.gov/",
        ),
        "MS": Jurisdiction(
            name="Mississippi",
            abbreviation="MS",
            type=JurisdictionType.STATE,
            fips_code="28",
            statutes_url="https://law.justia.com/codes/mississippi/",
            legislature_url="http://legislature.ms.gov/",
        ),
        "MO": Jurisdiction(
            name="Missouri",
            abbreviation="MO",
            type=JurisdictionType.STATE,
            fips_code="29",
            statutes_url="https://revisor.mo.gov/main/Home.aspx",
            legislature_url="https://www.senate.mo.gov/",
        ),
        "MT": Jurisdiction(
            name="Montana",
            abbreviation="MT",
            type=JurisdictionType.STATE,
            fips_code="30",
            statutes_url="https://leg.mt.gov/bills/mca/",
            legislature_url="https://leg.mt.gov/",
        ),
        "NE": Jurisdiction(
            name="Nebraska",
            abbreviation="NE",
            type=JurisdictionType.STATE,
            fips_code="31",
            statutes_url="https://nebraskalegislature.gov/laws/browse-statutes.php",
            legislature_url="https://nebraskalegislature.gov/",
        ),
        "NV": Jurisdiction(
            name="Nevada",
            abbreviation="NV",
            type=JurisdictionType.STATE,
            fips_code="32",
            statutes_url="https://www.leg.state.nv.us/NRS/",
            legislature_url="https://www.leg.state.nv.us/",
        ),
        "NH": Jurisdiction(
            name="New Hampshire",
            abbreviation="NH",
            type=JurisdictionType.STATE,
            fips_code="33",
            statutes_url="http://www.gencourt.state.nh.us/rsa/html/indexes/",
            legislature_url="http://www.gencourt.state.nh.us/",
        ),
        "NJ": Jurisdiction(
            name="New Jersey",
            abbreviation="NJ",
            type=JurisdictionType.STATE,
            fips_code="34",
            statutes_url="https://lis.njleg.state.nj.us/nxt/gateway.dll?f=templates&fn=default.htm",
            legislature_url="https://www.njleg.state.nj.us/",
        ),
        "NM": Jurisdiction(
            name="New Mexico",
            abbreviation="NM",
            type=JurisdictionType.STATE,
            fips_code="35",
            statutes_url="https://nmonesource.com/nmos/nmsa/en/nav.do",
            legislature_url="https://www.nmlegis.gov/",
        ),
        "NY": Jurisdiction(
            name="New York",
            abbreviation="NY",
            type=JurisdictionType.STATE,
            fips_code="36",
            statutes_url="https://www.nysenate.gov/legislation/laws/CONSOLIDATED",
            regulations_url="https://govt.westlaw.com/nycrr",
            legislature_url="https://www.nysenate.gov/",
        ),
        "NC": Jurisdiction(
            name="North Carolina",
            abbreviation="NC",
            type=JurisdictionType.STATE,
            fips_code="37",
            statutes_url="https://www.ncleg.gov/Laws/GeneralStatutes",
            legislature_url="https://www.ncleg.gov/",
        ),
        "ND": Jurisdiction(
            name="North Dakota",
            abbreviation="ND",
            type=JurisdictionType.STATE,
            fips_code="38",
            statutes_url="https://www.legis.nd.gov/general-information/north-dakota-century-code",
            legislature_url="https://www.legis.nd.gov/",
        ),
        "OH": Jurisdiction(
            name="Ohio",
            abbreviation="OH",
            type=JurisdictionType.STATE,
            fips_code="39",
            statutes_url="https://codes.ohio.gov/ohio-revised-code",
            legislature_url="https://www.legislature.ohio.gov/",
        ),
        "OK": Jurisdiction(
            name="Oklahoma",
            abbreviation="OK",
            type=JurisdictionType.STATE,
            fips_code="40",
            statutes_url="http://www.oklegislature.gov/osStatuesTitle.aspx",
            legislature_url="http://www.oklegislature.gov/",
        ),
        "OR": Jurisdiction(
            name="Oregon",
            abbreviation="OR",
            type=JurisdictionType.STATE,
            fips_code="41",
            statutes_url="https://www.oregonlegislature.gov/bills_laws/Pages/ORS.aspx",
            legislature_url="https://www.oregonlegislature.gov/",
        ),
        "PA": Jurisdiction(
            name="Pennsylvania",
            abbreviation="PA",
            type=JurisdictionType.STATE,
            fips_code="42",
            statutes_url="https://www.legis.state.pa.us/cfdocs/legis/LI/Public/cons_index.cfm",
            legislature_url="https://www.legis.state.pa.us/",
        ),
        "RI": Jurisdiction(
            name="Rhode Island",
            abbreviation="RI",
            type=JurisdictionType.STATE,
            fips_code="44",
            statutes_url="http://webserver.rilin.state.ri.us/Statutes/",
            legislature_url="http://www.rilegislature.gov/",
        ),
        "SC": Jurisdiction(
            name="South Carolina",
            abbreviation="SC",
            type=JurisdictionType.STATE,
            fips_code="45",
            statutes_url="https://www.scstatehouse.gov/code/statmast.php",
            legislature_url="https://www.scstatehouse.gov/",
        ),
        "SD": Jurisdiction(
            name="South Dakota",
            abbreviation="SD",
            type=JurisdictionType.STATE,
            fips_code="46",
            statutes_url="https://sdlegislature.gov/Statutes/Codified_Laws/",
            legislature_url="https://sdlegislature.gov/",
        ),
        "TN": Jurisdiction(
            name="Tennessee",
            abbreviation="TN",
            type=JurisdictionType.STATE,
            fips_code="47",
            statutes_url="https://advance.lexis.com/container?config=014CJAA5ZGVhZjA3NS02MmMzLTRlZWQtOGJjNC00YzQ1MmZlNzc2YWYKAFBvZENhdGFsb2e9zYpNUjTRaIWVfyrur9ud&crid=84b2d88e-a4a1-4f1c-9e13-f24a42addd29",
            legislature_url="https://www.capitol.tn.gov/",
        ),
        "TX": Jurisdiction(
            name="Texas",
            abbreviation="TX",
            type=JurisdictionType.STATE,
            fips_code="48",
            statutes_url="https://statutes.capitol.texas.gov/",
            regulations_url="https://texreg.sos.state.tx.us/public/readtac$ext.viewtac",
            legislature_url="https://capitol.texas.gov/",
        ),
        "UT": Jurisdiction(
            name="Utah",
            abbreviation="UT",
            type=JurisdictionType.STATE,
            fips_code="49",
            statutes_url="https://le.utah.gov/xcode/code.html",
            legislature_url="https://le.utah.gov/",
        ),
        "VT": Jurisdiction(
            name="Vermont",
            abbreviation="VT",
            type=JurisdictionType.STATE,
            fips_code="50",
            statutes_url="https://legislature.vermont.gov/statutes/",
            legislature_url="https://legislature.vermont.gov/",
        ),
        "VA": Jurisdiction(
            name="Virginia",
            abbreviation="VA",
            type=JurisdictionType.STATE,
            fips_code="51",
            statutes_url="https://law.lis.virginia.gov/vacode/",
            legislature_url="https://virginiageneralassembly.gov/",
        ),
        "WA": Jurisdiction(
            name="Washington",
            abbreviation="WA",
            type=JurisdictionType.STATE,
            fips_code="53",
            statutes_url="https://apps.leg.wa.gov/rcw/",
            legislature_url="https://leg.wa.gov/",
        ),
        "WV": Jurisdiction(
            name="West Virginia",
            abbreviation="WV",
            type=JurisdictionType.STATE,
            fips_code="54",
            statutes_url="http://www.wvlegislature.gov/WVCODE/code.cfm",
            legislature_url="http://www.wvlegislature.gov/",
        ),
        "WI": Jurisdiction(
            name="Wisconsin",
            abbreviation="WI",
            type=JurisdictionType.STATE,
            fips_code="55",
            statutes_url="https://docs.legis.wisconsin.gov/statutes/statutes",
            legislature_url="https://legis.wisconsin.gov/",
        ),
        "WY": Jurisdiction(
            name="Wyoming",
            abbreviation="WY",
            type=JurisdictionType.STATE,
            fips_code="56",
            statutes_url="https://wyoleg.gov/NXT/gateway.dll?f=templates&fn=default.htm",
            legislature_url="https://wyoleg.gov/",
        ),
    }
    
    # =================================================================
    # TERRITORIES
    # =================================================================
    
    TERRITORIES = {
        "DC": Jurisdiction(
            name="District of Columbia",
            abbreviation="DC",
            type=JurisdictionType.TERRITORIAL,
            fips_code="11",
            statutes_url="https://code.dccouncil.us/us/dc/council/code/",
            legislature_url="https://dccouncil.gov/",
        ),
        "PR": Jurisdiction(
            name="Puerto Rico",
            abbreviation="PR",
            type=JurisdictionType.TERRITORIAL,
            fips_code="72",
            legislature_url="https://www.oslpr.org/",
        ),
        "GU": Jurisdiction(
            name="Guam",
            abbreviation="GU",
            type=JurisdictionType.TERRITORIAL,
            fips_code="66",
            legislature_url="http://www.guamlegislature.com/",
        ),
        "VI": Jurisdiction(
            name="U.S. Virgin Islands",
            abbreviation="VI",
            type=JurisdictionType.TERRITORIAL,
            fips_code="78",
            legislature_url="https://www.legvi.org/",
        ),
        "AS": Jurisdiction(
            name="American Samoa",
            abbreviation="AS",
            type=JurisdictionType.TERRITORIAL,
            fips_code="60",
        ),
        "MP": Jurisdiction(
            name="Northern Mariana Islands",
            abbreviation="MP",
            type=JurisdictionType.TERRITORIAL,
            fips_code="69",
        ),
    }
    
    # =================================================================
    # METHODS
    # =================================================================
    
    @classmethod
    def get_all_jurisdictions(cls) -> Dict[str, Jurisdiction]:
        """Get all jurisdictions"""
        all_jurisdictions = {}
        all_jurisdictions.update(cls.STATES)
        all_jurisdictions.update(cls.TERRITORIES)
        return all_jurisdictions
    
    @classmethod
    def get_jurisdiction(cls, abbreviation: str) -> Optional[Jurisdiction]:
        """Get jurisdiction by abbreviation"""
        abbr = abbreviation.upper()
        if abbr in cls.STATES:
            return cls.STATES[abbr]
        if abbr in cls.TERRITORIES:
            return cls.TERRITORIES[abbr]
        return None
    
    @classmethod
    def get_federal_courts(cls) -> List[Court]:
        """Get all federal courts"""
        return cls.FEDERAL_COURTS
    
    @classmethod
    def get_circuit_for_state(cls, state_abbr: str) -> Optional[str]:
        """Get federal circuit for a state"""
        circuit_map = {
            "ME": "1st", "MA": "1st", "NH": "1st", "RI": "1st", "PR": "1st",
            "CT": "2d", "NY": "2d", "VT": "2d",
            "DE": "3d", "NJ": "3d", "PA": "3d", "VI": "3d",
            "MD": "4th", "NC": "4th", "SC": "4th", "VA": "4th", "WV": "4th",
            "LA": "5th", "MS": "5th", "TX": "5th",
            "KY": "6th", "MI": "6th", "OH": "6th", "TN": "6th",
            "IL": "7th", "IN": "7th", "WI": "7th",
            "AR": "8th", "IA": "8th", "MN": "8th", "MO": "8th", "NE": "8th", "ND": "8th", "SD": "8th",
            "AK": "9th", "AZ": "9th", "CA": "9th", "GU": "9th", "HI": "9th", "ID": "9th", 
            "MT": "9th", "NV": "9th", "MP": "9th", "OR": "9th", "WA": "9th",
            "CO": "10th", "KS": "10th", "NM": "10th", "OK": "10th", "UT": "10th", "WY": "10th",
            "AL": "11th", "FL": "11th", "GA": "11th",
            "DC": "D.C.",
        }
        return circuit_map.get(state_abbr.upper())
    
    @classmethod
    def get_state_abbreviations(cls) -> List[str]:
        """Get all state abbreviations"""
        return list(cls.STATES.keys())
    
    @classmethod
    def search_jurisdictions(cls, query: str) -> List[Jurisdiction]:
        """Search jurisdictions by name"""
        query_lower = query.lower()
        results = []
        for jurisdiction in cls.get_all_jurisdictions().values():
            if query_lower in jurisdiction.name.lower() or query_lower == jurisdiction.abbreviation.lower():
                results.append(jurisdiction)
        return results
```

---

## ðŸ“„ FILE 8: core/__init__.py

```python
"""
JAIPI-JUDICIAL V4 Core Package
Central orchestration and engine components
"""

from .engine import JAIPIEngine
from .orchestrator import AgentOrchestrator
from .state_machine import StateMachine, State, Transition
from .event_bus import EventBus, Event, EventType
from .message_queue import MessageQueue, Message, Priority
from .scheduler import TaskScheduler, ScheduledTask
from .cache_manager import CacheManager
from .context_manager import ContextManager, ExecutionContext

__all__ = [
    "JAIPIEngine",
    "AgentOrchestrator",
    "StateMachine",
    "State",
    "Transition",
    "EventBus",
    "Event",
    "EventType",
    "MessageQueue",
    "Message",
    "Priority",
    "TaskScheduler",
    "ScheduledTask",
    "CacheManager",
    "ContextManager",
    "ExecutionContext",
]
```

---

## ðŸ“„ FILE 9: core/engine.py

```python
"""
JAIPI-JUDICIAL V4 Core Engine
Main orchestration engine for the entire system
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Type, Callable
from datetime import datetime, timezone
from dataclasses import dataclass, field
from enum import Enum, auto
from contextlib import asynccontextmanager
import signal
import sys

from config import Settings, get_settings
from config.constants import SystemConstants, AgentConstants


class EngineState(Enum):
    """Engine operational states"""
    INITIALIZING = auto()
    STARTING = auto()
    RUNNING = auto()
    PAUSED = auto()
    STOPPING = auto()
    STOPPED = auto()
    ERROR = auto()
    MAINTENANCE = auto()


@dataclass
class EngineMetrics:
    """Engine performance metrics"""
    start_time: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    active_agents: int = 0
    queued_tasks: int = 0
    cache_hits: int = 0
    cache_misses: int = 0
    average_response_time_ms: float = 0.0
    
    @property
    def uptime_seconds(self) -> float:
        return (datetime.now(timezone.utc) - self.start_time).total_seconds()
    
    @property
    def success_rate(self) -> float:
        if self.total_requests == 0:
            return 1.0
        return self.successful_requests / self.total_requests


@dataclass
class EngineConfig:
    """Engine configuration"""
    max_workers: int = 50
    max_queue_size: int = 10000
    shutdown_timeout: int = 30
    health_check_interval: int = 30
    metrics_collection_interval: int = 10
    auto_scale: bool = True
    min_workers: int = 5
    scale_up_threshold: float = 0.8
    scale_down_threshold: float = 0.3


class JAIPIEngine:
    """
    JAIPI-JUDICIAL V4 Core Engine
    
    The central orchestration engine that manages:
    - Agent lifecycle
    - Task distribution
    - Resource allocation
    - System health monitoring
    - Event processing
    - Cache management
    """
    
    def __init__(
        self,
        settings: Optional[Settings] = None,
        config: Optional[EngineConfig] = None,
    ):
        self.settings = settings or get_settings()
        self.config = config or EngineConfig()
        
        # Core components (lazy initialized)
        self._orchestrator = None
        self._event_bus = None
        self._message_queue = None
        self._scheduler = None
        self._cache_manager = None
        self._context_manager = None
        
        # State management
        self._state = EngineState.INITIALIZING
        self._metrics = EngineMetrics()
        self._agents: Dict[str, Any] = {}
        self._workers: List[asyncio.Task] = []
        
        # Synchronization primitives
        self._lock = asyncio.Lock()
        self._shutdown_event = asyncio.Event()
        self._ready_event = asyncio.Event()
        
        # Logging
        self.logger = logging.getLogger(f"{__name__}.JAIPIEngine")
        
        # Signal handlers
        self._original_handlers: Dict[int, Any] = {}
        
    @property
    def state(self) -> EngineState:
        """Current engine state"""
        return self._state
    
    @property
    def metrics(self) -> EngineMetrics:
        """Current engine metrics"""
        return self._metrics
    
    @property
    def is_running(self) -> bool:
        """Check if engine is running"""
        return self._state == EngineState.RUNNING
    
    @property
    def is_healthy(self) -> bool:
        """Check engine health"""
        return (
            self._state in (EngineState.RUNNING, EngineState.PAUSED)
            and self._metrics.success_rate > 0.9
        )
    
    # =========================================================================
    # LIFECYCLE MANAGEMENT
    # =========================================================================
    
    async def initialize(self) -> None:
        """Initialize engine components"""
        self.logger.info("Initializing JAIPI Engine V4...")
        
        try:
            # Import here to avoid circular imports
            from .orchestrator import AgentOrchestrator
            from .event_bus import EventBus
            from .message_queue import MessageQueue
            from .scheduler import TaskScheduler
            from .cache_manager import CacheManager
            from .context_manager import ContextManager
            
            # Initialize components
            self._event_bus = EventBus()
            self._message_queue = MessageQueue(max_size=self.config.max_queue_size)
            self._cache_manager = CacheManager(settings=self.settings)
            self._context_manager = ContextManager()
            self._scheduler = TaskScheduler(event_bus=self._event_bus)
            self._orchestrator = AgentOrchestrator(
                event_bus=self._event_bus,
                message_queue=self._message_queue,
                cache_manager=self._cache_manager,
            )
            
            # Register shutdown handlers
            self._setup_signal_handlers()
            
            self._state = EngineState.STARTING
            self.logger.info("JAIPI Engine initialization complete")
            
        except Exception as e:
            self._state = EngineState.ERROR
            self.logger.error(f"Engine initialization failed: {e}")
            raise
    
    async def start(self) -> None:
        """Start the engine"""
        if self._state not in (EngineState.STARTING, EngineState.STOPPED):
            raise RuntimeError(f"Cannot start engine from state: {self._state}")
        
        self.logger.info("Starting JAIPI Engine...")
        
        try:
            # Start core components
            await self._event_bus.start()
            await self._message_queue.start()
            await self._scheduler.start()
            await self._orchestrator.start()
            
            # Start worker pool
            await self._start_workers()
            
            # Start background tasks
            asyncio.create_task(self._health_check_loop())
            asyncio.create_task(self._metrics_collection_loop())
            
            # Initialize all agents
            await self._initialize_agents()
            
            self._state = EngineState.RUNNING
            self._ready_event.set()
            self._metrics.start_time = datetime.now(timezone.utc)
            
            self.logger.info("JAIPI Engine started successfully")
            
        except Exception as e:
            self._state = EngineState.ERROR
            self.logger.error(f"Engine start failed: {e}")
            raise
    
    async def stop(self, timeout: Optional[int] = None) -> None:
        """Stop the engine gracefully"""
        if self._state in (EngineState.STOPPED, EngineState.STOPPING):
            return
        
        timeout = timeout or self.config.shutdown_timeout
        self.logger.info(f"Stopping JAIPI Engine (timeout: {timeout}s)...")
        
        self._state = EngineState.STOPPING
        self._shutdown_event.set()
        
        try:
            # Stop accepting new tasks
            await self._orchestrator.stop_accepting()
            
            # Wait for current tasks to complete
            await asyncio.wait_for(
                self._drain_queues(),
                timeout=timeout
            )
            
            # Stop workers
            await self._stop_workers()
            
            # Stop components
            await self._orchestrator.stop()
            await self._scheduler.stop()
            await self._message_queue.stop()
            await self._event_bus.stop()
            await self._cache_manager.close()
            
            self._state = EngineState.STOPPED
            self.logger.info("JAIPI Engine stopped successfully")
            
        except asyncio.TimeoutError:
            self.logger.warning("Shutdown timeout - forcing stop")
            await self._force_stop()
            
        except Exception as e:
            self.logger.error(f"Error during shutdown: {e}")
            await self._force_stop()
    
    async def restart(self) -> None:
        """Restart the engine"""
        self.logger.info("Restarting JAIPI Engine...")
        await self.stop()
        await self.initialize()
        await self.start()
    
    async def pause(self) -> None:
        """Pause task processing"""
        if self._state != EngineState.RUNNING:
            raise RuntimeError(f"Cannot pause from state: {self._state}")
        
        self.logger.info("Pausing JAIPI Engine...")
        self._state = EngineState.PAUSED
        await self._orchestrator.pause()
    
    async def resume(self) -> None:
        """Resume task processing"""
        if self._state != EngineState.PAUSED:
            raise RuntimeError(f"Cannot resume from state: {self._state}")
        
        self.logger.info("Resuming JAIPI Engine...")
        await self._orchestrator.resume()
        self._state = EngineState.RUNNING
    
    # =========================================================================
    # AGENT MANAGEMENT
    # =========================================================================
    
    async def _initialize_agents(self) -> None:
        """Initialize all configured agents"""
        from agents import (
            WatchdogAgent,
            ComplianceAgent,
            CitationAgent,
            PrecedentAgent,
            StatutoryAgent,
            ConstitutionalAgent,
            RegulatoryAgent,
            ProceduralAgent,
            EvidenceAgent,
            SentimentAgent,
            RiskAgent,
            AuditAgent,
            NotificationAgent,
            CoordinationAgent,
            FOIAAgent,
            EthicsAgent,
            JurisdictionAgent,
            TimelineAgent,
            DocumentAgent,
            APIMonitorAgent,
            BudgetAgent,
            TransparencyAgent,
            WhistleblowerAgent,
            ContractAgent,
            AdministrativeAgent,
            EnforcementAgent,
            AppealsAgent,
            LegislativeAgent,
            EmergencyAgent,
        )
        
        # Agent configurations with priorities
        agent_configs = [
            # Critical priority agents
            (WatchdogAgent, AgentConstants.Priority.CRITICAL, {"interval": 60}),
            (EmergencyAgent, AgentConstants.Priority.CRITICAL, {}),
            (AuditAgent, AgentConstants.Priority.CRITICAL, {}),
            
            # High priority agents
            (ComplianceAgent, AgentConstants.Priority.HIGH, {}),
            (ConstitutionalAgent, AgentConstants.Priority.HIGH, {}),
            (EnforcementAgent, AgentConstants.Priority.HIGH, {}),
            (WhistleblowerAgent, AgentConstants.Priority.HIGH, {}),
            
            # Medium priority agents
            (CitationAgent, AgentConstants.Priority.MEDIUM, {}),
            (PrecedentAgent, AgentConstants.Priority.MEDIUM, {"similarity_threshold": 0.85}),
            (StatutoryAgent, AgentConstants.Priority.MEDIUM, {}),
            (RegulatoryAgent, AgentConstants.Priority.MEDIUM, {}),
            (ProceduralAgent, AgentConstants.Priority.MEDIUM, {}),
            (JurisdictionAgent, AgentConstants.Priority.MEDIUM, {}),
            (LegislativeAgent, AgentConstants.Priority.MEDIUM, {}),
            (ContractAgent, AgentConstants.Priority.MEDIUM, {}),
            (AdministrativeAgent, AgentConstants.Priority.MEDIUM, {}),
            (AppealsAgent, AgentConstants.Priority.MEDIUM, {}),
            
            # Low priority agents
            (EvidenceAgent, AgentConstants.Priority.LOW, {}),
            (SentimentAgent, AgentConstants.Priority.LOW, {}),
            (RiskAgent, AgentConstants.Priority.LOW, {}),
            (TimelineAgent, AgentConstants.Priority.LOW, {}),
            (DocumentAgent, AgentConstants.Priority.LOW, {}),
            (BudgetAgent, AgentConstants.Priority.LOW, {}),
            (TransparencyAgent, AgentConstants.Priority.LOW, {}),
            (FOIAAgent, AgentConstants.Priority.LOW, {}),
            (EthicsAgent, AgentConstants.Priority.LOW, {}),
            
            # Background agents
            (NotificationAgent, AgentConstants.Priority.BACKGROUND, {}),
            (CoordinationAgent, AgentConstants.Priority.BACKGROUND, {}),
            (APIMonitorAgent, AgentConstants.Priority.BACKGROUND, {"check_interval": 300}),
        ]
        
        for agent_class, priority, config in agent_configs:
            try:
                agent = await self._orchestrator.register_agent(
                    agent_class=agent_class,
                    priority=priority,
                    config=config,
                )
                self._agents[agent.agent_id] = agent
                self._metrics.active_agents += 1
                self.logger.debug(f"Initialized agent: {agent_class.__name__}")
                
            except Exception as e:
                self.logger.error(f"Failed to initialize {agent_class.__name__}: {e}")
    
    async def register_agent(
        self,
        agent_class: Type,
        priority: AgentConstants.Priority = AgentConstants.Priority.MEDIUM,
        config: Optional[Dict[str, Any]] = None,
    ) -> str:
        """Register a new agent dynamically"""
        agent = await self._orchestrator.register_agent(
            agent_class=agent_class,
            priority=priority,
            config=config or {},
        )
        self._agents[agent.agent_id] = agent
        self._metrics.active_agents += 1
        return agent.agent_id
    
    async def unregister_agent(self, agent_id: str) -> None:
        """Unregister an agent"""
        if agent_id in self._agents:
            await self._orchestrator.unregister_agent(agent_id)
            del self._agents[agent_id]
            self._metrics.active_agents -= 1
    
    def get_agent(self, agent_id: str) -> Optional[Any]:
        """Get agent by ID"""
        return self._agents.get(agent_id)
    
    def list_agents(self) -> List[Dict[str, Any]]:
        """List all registered agents"""
        return [
            {
                "agent_id": agent_id,
                "type": agent.__class__.__name__,
                "state": agent.state.name if hasattr(agent, 'state') else "unknown",
                "priority": agent.priority.name if hasattr(agent, 'priority') else "unknown",
            }
            for agent_id, agent in self._agents.items()
        ]
    
    # =========================================================================
    # TASK PROCESSING
    # =========================================================================
    
    async def submit_task(
        self,
        task_type: str,
        payload: Dict[str, Any],
        priority: Optional[AgentConstants.Priority] = None,
        timeout: Optional[int] = None,
        callback: Optional[Callable] = None,
    ) -> str:
        """Submit a task for processing"""
        if not self.is_running:
            raise RuntimeError("Engine is not running")
        
        self._metrics.total_requests += 1
        
        try:
            task_id = await self._orchestrator.submit_task(
                task_type=task_type,
                payload=payload,
                priority=priority or AgentConstants.Priority.MEDIUM,
                timeout=timeout,
                callback=callback,
            )
            return task_id
            
        except Exception as e:
            self._metrics.failed_requests += 1
            raise
    
    async def get_task_result(
        self,
        task_id: str,
        timeout: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Get result of a submitted task"""
        return await self._orchestrator.get_task_result(task_id, timeout)
    
    async def cancel_task(self, task_id: str) -> bool:
        """Cancel a pending task"""
        return await self._orchestrator.cancel_task(task_id)
    
    # =========================================================================
    # WORKER MANAGEMENT
    # =========================================================================
    
    async def _start_workers(self) -> None:
        """Start worker tasks"""
        num_workers = self.config.max_workers
        self.logger.info(f"Starting {num_workers} workers...")
        
        for i in range(num_workers):
            worker = asyncio.create_task(
                self._worker_loop(worker_id=i),
                name=f"jaipi-worker-{i}"
            )
            self._workers.append(worker)
    
    async def _stop_workers(self) -> None:
        """Stop all workers"""
        self.logger.info("Stopping workers...")
        
        for worker in self._workers:
            worker.cancel()
        
        if self._workers:
            await asyncio.gather(*self._workers, return_exceptions=True)
        
        self._workers.clear()
    
    async def _worker_loop(self, worker_id: int) -> None:
        """Main worker loop"""
        self.logger.debug(f"Worker {worker_id} started")
        
        while not self._shutdown_event.is_set():
            try:
                if self._state == EngineState.PAUSED:
                    await asyncio.sleep(1)
                    continue
                
                # Get next task from queue
                task = await asyncio.wait_for(
                    self._message_queue.get(),
                    timeout=1.0
                )
                
                if task:
                    start_time = datetime.now(timezone.utc)
                    
                    try:
                        result = await self._orchestrator.process_task(task)
                        self._metrics.successful_requests += 1
                        
                        # Update average response time
                        elapsed = (datetime.now(timezone.utc) - start_time).total_seconds() * 1000
                        self._update_response_time(elapsed)
                        
                    except Exception as e:
                        self._metrics.failed_requests += 1
                        self.logger.error(f"Worker {worker_id} task error: {e}")
                    
                    finally:
                        self._message_queue.task_done()
                
            except asyncio.TimeoutError:
                continue
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Worker {worker_id} error: {e}")
                await asyncio.sleep(1)
        
        self.logger.debug(f"Worker {worker_id} stopped")
    
    def _update_response_time(self, elapsed_ms: float) -> None:
        """Update rolling average response time"""
        if self._metrics.average_response_time_ms == 0:
            self._metrics.average_response_time_ms = elapsed_ms
        else:
            # Exponential moving average
            alpha = 0.1
            self._metrics.average_response_time_ms = (
                alpha * elapsed_ms + 
                (1 - alpha) * self._metrics.average_response_time_ms
            )
    
    # =========================================================================
    # MONITORING & HEALTH
    # =========================================================================
    
    async def _health_check_loop(self) -> None:
        """Periodic health check loop"""
        while not self._shutdown_event.is_set():
            try:
                await asyncio.sleep(self.config.health_check_interval)
                await self._perform_health_check()
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Health check error: {e}")
    
    async def _perform_health_check(self) -> Dict[str, Any]:
        """Perform comprehensive health check"""
        health = {
            "status": "healthy" if self.is_healthy else "degraded",
            "state": self._state.name,
            "uptime_seconds": self._metrics.uptime_seconds,
            "success_rate": self._metrics.success_rate,
            "active_agents": self._metrics.active_agents,
            "queued_tasks": self._message_queue.qsize() if self._message_queue else 0,
            "workers": len(self._workers),
            "components": {},
        }
        
        # Check components
        if self._orchestrator:
            health["components"]["orchestrator"] = await self._orchestrator.health_check()
        if self._event_bus:
            health["components"]["event_bus"] = self._event_bus.is_running
        if self._message_queue:
            health["components"]["message_queue"] = self._message_queue.is_running
        if self._cache_manager:
            health["components"]["cache"] = await self._cache_manager.health_check()
        
        # Auto-scaling check
        if self.config.auto_scale:
            await self._check_auto_scale()
        
        return health
    
    async def _metrics_collection_loop(self) -> None:
        """Periodic metrics collection"""
        while not self._shutdown_event.is_set():
            try:
                await asyncio.sleep(self.config.metrics_collection_interval)
                self._metrics.queued_tasks = (
                    self._message_queue.qsize() if self._message_queue else 0
                )
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Metrics collection error: {e}")
    
    async def _check_auto_scale(self) -> None:
        """Check and perform auto-scaling if needed"""
        if not self._message_queue:
            return
        
        queue_utilization = (
            self._message_queue.qsize() / self.config.max_queue_size
        )
        
        if queue_utilization > self.config.scale_up_threshold:
            # Scale up
            current_workers = len(self._workers)
            if current_workers < self.config.max_workers:
                new_worker = asyncio.create_task(
                    self._worker_loop(worker_id=current_workers),
                    name=f"jaipi-worker-{current_workers}"
                )
                self._workers.append(new_worker)
                self.logger.info(f"Scaled up to {len(self._workers)} workers")
        
        elif queue_utilization < self.config.scale_down_threshold:
            # Scale down
            current_workers = len(self._workers)
            if current_workers > self.config.min_workers:
                worker = self._workers.pop()
                worker.cancel()
                self.logger.info(f"Scaled down to {len(self._workers)} workers")
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get current metrics as dictionary"""
        return {
            "uptime_seconds": self._metrics.uptime_seconds,
            "total_requests": self._metrics.total_requests,
            "successful_requests": self._metrics.successful_requests,
            "failed_requests": self._metrics.failed_requests,
            "success_rate": self._metrics.success_rate,
            "active_agents": self._metrics.active_agents,
            "queued_tasks": self._metrics.queued_tasks,
            "cache_hits": self._metrics.cache_hits,
            "cache_misses": self._metrics.cache_misses,
            "average_response_time_ms": self._metrics.average_response_time_ms,
            "workers": len(self._workers),
        }
    
    # =========================================================================
    # INTERNAL UTILITIES
    # =========================================================================
    
    async def _drain_queues(self) -> None:
        """Drain all queues before shutdown"""
        if self._message_queue:
            await self._message_queue.join()
    
    async def _force_stop(self) -> None:
        """Force stop all components"""
        self.logger.warning("Force stopping engine...")
        
        # Cancel all workers
        for worker in self._workers:
            worker.cancel()
        
        self._workers.clear()
        self._state = EngineState.STOPPED
    
    def _setup_signal_handlers(self) -> None:
        """Setup signal handlers for graceful shutdown"""
        if sys.platform != "win32":
            loop = asyncio.get_event_loop()
            
            for sig in (signal.SIGTERM, signal.SIGINT):
                self._original_handlers[sig] = signal.getsignal(sig)
                loop.add_signal_handler(
                    sig,
                    lambda s=sig: asyncio.create_task(self._signal_handler(s))
                )
    
    async def _signal_handler(self, sig: signal.Signals) -> None:
        """Handle shutdown signals"""
        self.logger.info(f"Received signal {sig.name}")
        await self.stop()
    
    def _restore_signal_handlers(self) -> None:
        """Restore original signal handlers"""
        if sys.platform != "win32":
            loop = asyncio.get_event_loop()
            
            for sig, handler in self._original_handlers.items():
                loop.remove_signal_handler(sig)
                if handler:
                    signal.signal(sig, handler)
    
    # =========================================================================
    # CONTEXT MANAGER
    # =========================================================================
    
    @asynccontextmanager
    async def running(self):
        """Context manager for running the engine"""
        try:
            await self.initialize()
            await self.start()
            yield self
        finally:
            await self.stop()
            self._restore_signal_handlers()
    
    async def wait_until_ready(self, timeout: Optional[float] = None) -> bool:
        """Wait until engine is ready"""
        try:
            await asyncio.wait_for(self._ready_event.wait(), timeout=timeout)
            return True
        except asyncio.TimeoutError:
            return False
    
    async def wait_until_stopped(self) -> None:
        """Wait until engine is stopped"""
        await self._shutdown_event.wait()
```

---

## ðŸ“„ FILE 10: core/orchestrator.py

```python
"""
JAIPI-JUDICIAL V4 Agent Orchestrator
Manages agent lifecycle, task distribution, and coordination
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Type, Callable, Set
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum, auto
import uuid
import traceback

from config.constants import AgentConstants


class TaskState(Enum):
    """Task execution states"""
    PENDING = auto()
    QUEUED = auto()
    ASSIGNED = auto()
    PROCESSING = auto()
    COMPLETED = auto()
    FAILED = auto()
    CANCELLED = auto()
    TIMEOUT = auto()


@dataclass
class Task:
    """Represents a task to be processed"""
    task_id: str
    task_type: str
    payload: Dict[str, Any]
    priority: AgentConstants.Priority
    state: TaskState = TaskState.PENDING
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    assigned_agent: Optional[str] = None
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    timeout: Optional[int] = None
    callback: Optional[Callable] = None
    retries: int = 0
    max_retries: int = 3
    
    @property
    def elapsed_time(self) -> Optional[float]:
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None


@dataclass
class AgentRegistration:
    """Agent registration information"""
    agent_id: str
    agent_class: Type
    instance: Any
    priority: AgentConstants.Priority
    config: Dict[str, Any]
    registered_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    task_types: Set[str] = field(default_factory=set)
    current_task: Optional[str] = None
    tasks_completed: int = 0
    tasks_failed: int = 0
    is_available: bool = True


class AgentOrchestrator:
    """
    Agent Orchestrator
    
    Responsibilities:
    - Agent registration and lifecycle management
    - Task routing and distribution
    - Load balancing across agents
    - Task result aggregation
    - Failure handling and retry logic
    - Agent coordination for complex workflows
    """
    
    def __init__(
        self,
        event_bus: Any,
        message_queue: Any,
        cache_manager: Any,
    ):
        self.event_bus = event_bus
        self.message_queue = message_queue
        self.cache_manager = cache_manager
        
        # Agent management
        self._agents: Dict[str, AgentRegistration] = {}
        self._agent_type_map: Dict[str, List[str]] = {}  # task_type -> agent_ids
        
        # Task management
        self._tasks: Dict[str, Task] = {}
        self._task_results: Dict[str, asyncio.Future] = {}
        
        # State
        self._accepting_tasks = True
        self._paused = False
        self._running = False
        
        # Synchronization
        self._lock = asyncio.Lock()
        self._agent_semaphore = asyncio.Semaphore(100)  # Max concurrent agent operations
        
        # Logging
        self.logger = logging.getLogger(f"{__name__}.AgentOrchestrator")
    
    # =========================================================================
    # LIFECYCLE
    # =========================================================================
    
    async def start(self) -> None:
        """Start the orchestrator"""
        self.logger.info("Starting Agent Orchestrator...")
        self._running = True
        
        # Start background tasks
        asyncio.create_task(self._cleanup_loop())
        asyncio.create_task(self._monitoring_loop())
        
        self.logger.info("Agent Orchestrator started")
    
    async def stop(self) -> None:
        """Stop the orchestrator"""
        self.logger.info("Stopping Agent Orchestrator...")
        self._running = False
        self._accepting_tasks = False
        
        # Stop all agents
        for agent_id in list(self._agents.keys()):
            await self.unregister_agent(agent_id)
        
        self.logger.info("Agent Orchestrator stopped")
    
    async def stop_accepting(self) -> None:
        """Stop accepting new tasks"""
        self._accepting_tasks = False
    
    async def pause(self) -> None:
        """Pause task processing"""
        self._paused = True
    
    async def resume(self) -> None:
        """Resume task processing"""
        self._paused = False
    
    # =========================================================================
    # AGENT MANAGEMENT
    # =========================================================================
    
    async def register_agent(
        self,
        agent_class: Type,
        priority: AgentConstants.Priority,
        config: Dict[str, Any],
    ) -> Any:
        """Register a new agent"""
        async with self._lock:
            agent_id = f"{agent_class.__name__}_{uuid.uuid4().hex[:8]}"
            
            # Instantiate agent
            instance = agent_class(
                agent_id=agent_id,
                orchestrator=self,
                event_bus=self.event_bus,
                cache_manager=self.cache_manager,
                config=config,
            )
            
            # Initialize agent
            await instance.initialize()
            
            # Get supported task types
            task_types = set(instance.supported_task_types) if hasattr(instance, 'supported_task_types') else set()
            
            # Create registration
            registration = AgentRegistration(
                agent_id=agent_id,
                agent_class=agent_class,
                instance=instance,
                priority=priority,
                config=config,
                task_types=task_types,
            )
            
            self._agents[agent_id] = registration
            
            # Update task type mapping
            for task_type in task_types:
                if task_type not in self._agent_type_map:
                    self._agent_type_map[task_type] = []
                self._agent_type_map[task_type].append(agent_id)
            
            self.logger.info(f"Registered agent: {agent_id} (priority: {priority.name})")
            
            return instance
    
    async def unregister_agent(self, agent_id: str) -> None:
        """Unregister an agent"""
        async with self._lock:
            if agent_id not in self._agents:
                return
            
            registration = self._agents[agent_id]
            
            # Shutdown agent
            try:
                await registration.instance.shutdown()
            except Exception as e:
                self.logger.error(f"Error shutting down agent {agent_id}: {e}")
            
            # Remove from task type mapping
            for task_type in registration.task_types:
                if task_type in self._agent_type_map:
                    self._agent_type_map[task_type].remove(agent_id)
            
            del self._agents[agent_id]
            self.logger.info(f"Unregistered agent: {agent_id}")
    
    def get_agent(self, agent_id: str) -> Optional[Any]:
        """Get agent instance by ID"""
        if agent_id in self._agents:
            return self._agents[agent_id].instance
        return None
    
    def get_available_agents(self, task_type: Optional[str] = None) -> List[str]:
        """Get list of available agents"""
        available = []
        
        for agent_id, registration in self._agents.items():
            if not registration.is_available:
                continue
            if task_type and task_type not in registration.task_types:
                continue
            available.append(agent_id)
        
        return available
    
    # =========================================================================
    # TASK MANAGEMENT
    # =========================================================================
    
    async def submit_task(
        self,
        task_type: str,
        payload: Dict[str, Any],
        priority: AgentConstants.Priority,
        timeout: Optional[int] = None,
        callback: Optional[Callable] = None,
    ) -> str:
        """Submit a task for processing"""
        if not self._accepting_tasks:
            raise RuntimeError("Orchestrator is not accepting tasks")
        
        task_id = f"task_{uuid.uuid4().hex}"
        
        task = Task(
            task_id=task_id,
            task_type=task_type,
            payload=payload,
            priority=priority,
            timeout=timeout,
            callback=callback,
        )
        
        self._tasks[task_id] = task
        self._task_results[task_id] = asyncio.get_event_loop().create_future()
        
        # Route task to appropriate agent
        await self._route_task(task)
        
        return task_id
    
    async def _route_task(self, task: Task) -> None:
        """Route task to appropriate agent"""
        task.state = TaskState.QUEUED
        
        # Find available agents for this task type
        available_agents = self.get_available_agents(task.task_type)
        
        if not available_agents:
            # Check for fallback agents
            available_agents = self.get_available_agents()
        
        if not available_agents:
            task.state = TaskState.FAILED
            task.error = "No available agents"
            self._complete_task(task)
            return
        
        # Select agent based on priority and load
        selected_agent = await self._select_agent(available_agents, task)
        
        if selected_agent:
            await self._assign_task(task, selected_agent)
        else:
            # Queue task for later
            await self.message_queue.put(task, priority=task.priority.value)
    
    async def _select_agent(
        self,
        available_agents: List[str],
        task: Task,
    ) -> Optional[str]:
        """Select best agent for task"""
        candidates = []
        
        for agent_id in available_agents:
            registration = self._agents.get(agent_id)
            if not registration or not registration.is_available:
                continue
            
            # Score agent
            score = self._calculate_agent_score(registration, task)
            candidates.append((agent_id, score))
        
        if not candidates:
            return None
        
        # Sort by score (higher is better)
        candidates.sort(key=lambda x: x[1], reverse=True)
        return candidates[0][0]
    
    def _calculate_agent_score(
        self,
        registration: AgentRegistration,
        task: Task,
    ) -> float:
        """Calculate agent suitability score for task"""
        score = 100.0
        
        # Priority match bonus
        if registration.priority.value <= task.priority.value:
            score += 20
        
        # Task type match bonus
        if task.task_type in registration.task_types:
            score += 30
        
        # Success rate bonus
        total_tasks = registration.tasks_completed + registration.tasks_failed
        if total_tasks > 0:
            success_rate = registration.tasks_completed / total_tasks
            score += success_rate * 20
        
        # Availability penalty
        if registration.current_task:
            score -= 50
        
        return score
    
    async def _assign_task(self, task: Task, agent_id: str) -> None:
        """Assign task to agent"""
        registration = self._agents.get(agent_id)
        if not registration:
            return
        
        task.state = TaskState.ASSIGNED
        task.assigned_agent = agent_id
        registration.current_task = task.task_id
        registration.is_available = False
        
        # Execute task
        asyncio.create_task(self._execute_task(task, registration))
    
    async def _execute_task(
        self,
        task: Task,
        registration: AgentRegistration,
    ) -> None:
        """Execute task on agent"""
        task.state = TaskState.PROCESSING
        task.started_at = datetime.now(timezone.utc)
        
        try:
            async with self._agent_semaphore:
                # Apply timeout if specified
                if task.timeout:
                    result = await asyncio.wait_for(
                        registration.instance.execute(task),
                        timeout=task.timeout
                    )
                else:
                    result = await registration.instance.execute(task)
                
                task.result = result
                task.state = TaskState.COMPLETED
                registration.tasks_completed += 1
        
        except asyncio.TimeoutError:
            task.state = TaskState.TIMEOUT
            task.error = f"Task timed out after {task.timeout}s"
            registration.tasks_failed += 1
            
            # Retry if possible
            if task.retries < task.max_retries:
                task.retries += 1
                await self._route_task(task)
                return
        
        except Exception as e:
            task.state = TaskState.FAILED
            task.error = str(e)
            registration.tasks_failed += 1
            self.logger.error(f"Task {task.task_id} failed: {e}\n{traceback.format_exc()}")
            
            # Retry if possible
            if task.retries < task.max_retries:
                task.retries += 1
                await asyncio.sleep(2 ** task.retries)  # Exponential backoff
                await self._route_task(task)
                return
        
        finally:
            task.completed_at = datetime.now(timezone.utc)
            registration.current_task = None
            registration.is_available = True
        
        self._complete_task(task)
    
    def _complete_task(self, task: Task) -> None:
        """Complete task and notify waiters"""
        # Set future result
        if task.task_id in self._task_results:
            future = self._task_results[task.task_id]
            if not future.done():
                if task.state == TaskState.COMPLETED:
                    future.set_result(task.result)
                else:
                    future.set_exception(
                        Exception(task.error or f"Task failed with state: {task.state}")
                    )
        
        # Execute callback
        if task.callback:
            try:
                asyncio.create_task(self._execute_callback(task))
            except Exception as e:
                self.logger.error(f"Task callback error: {e}")
    
    async def _execute_callback(self, task: Task) -> None:
        """Execute task callback"""
        try:
            if asyncio.iscoroutinefunction(task.callback):
                await task.callback(task)
            else:
                task.callback(task)
        except Exception as e:
            self.logger.error(f"Callback error for task {task.task_id}: {e}")
    
    async def get_task_result(
        self,
        task_id: str,
        timeout: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Get task result (blocking)"""
        if task_id not in self._task_results:
            raise KeyError(f"Unknown task: {task_id}")
        
        future = self._task_results[task_id]
        
        try:
            if timeout:
                result = await asyncio.wait_for(future, timeout=timeout)
            else:
                result = await future
            return result
        except asyncio.TimeoutError:
            raise TimeoutError(f"Timeout waiting for task {task_id}")
    
    async def cancel_task(self, task_id: str) -> bool:
        """Cancel a pending task"""
        if task_id not in self._tasks:
            return False
        
        task = self._tasks[task_id]
        
        if task.state in (TaskState.PENDING, TaskState.QUEUED):
            task.state = TaskState.CANCELLED
            self._complete_task(task)
            return True
        
        return False
    
    def get_task_status(self, task_id: str) -> Optional[Dict[str, Any]]:
        """Get task status"""
        if task_id not in self._tasks:
            return None
        
        task = self._tasks[task_id]
        return {
            "task_id": task.task_id,
            "task_type": task.task_type,
            "state": task.state.name,
            "priority": task.priority.name,
            "assigned_agent": task.assigned_agent,
            "created_at": task.created_at.isoformat(),
            "started_at": task.started_at.isoformat() if task.started_at else None,
            "completed_at": task.completed_at.isoformat() if task.completed_at else None,
            "elapsed_time": task.elapsed_time,
            "retries": task.retries,
            "error": task.error,
        }
    
    # =========================================================================
    # COORDINATION
    # =========================================================================
    
    async def coordinate_workflow(
        self,
        workflow_id: str,
        steps: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """
        Coordinate a multi-agent workflow
        
        Each step contains:
        - task_type: Type of task
        - payload: Task payload
        - depends_on: List of step indices this step depends on
        """
        results = {}
        step_tasks = {}
        
        # Group steps by dependency level
        levels = self._topological_sort(steps)
        
        for level in levels:
            # Execute steps at this level in parallel
            tasks = []
            
            for step_idx in level:
                step = steps[step_idx]
                
                # Build payload with dependencies
                payload = step.get("payload", {}).copy()
                
                for dep_idx in step.get("depends_on", []):
                    if dep_idx in results:
                        payload[f"dep_{dep_idx}_result"] = results[dep_idx]
                
                task_id = await self.submit_task(
                    task_type=step["task_type"],
                    payload=payload,
                    priority=step.get("priority", AgentConstants.Priority.MEDIUM),
                )
                
                step_tasks[step_idx] = task_id
                tasks.append((step_idx, task_id))
            
            # Wait for all tasks at this level
            for step_idx, task_id in tasks:
                try:
                    result = await self.get_task_result(task_id, timeout=300)
                    results[step_idx] = result
                except Exception as e:
                    results[step_idx] = {"error": str(e)}
        
        return {
            "workflow_id": workflow_id,
            "results": results,
            "completed": all("error" not in r for r in results.values() if isinstance(r, dict)),
        }
    
    def _topological_sort(
        self,
        steps: List[Dict[str, Any]],
    ) -> List[List[int]]:
        """Topologically sort workflow steps into levels"""
        n = len(steps)
        in_degree = [0] * n
        adj = [[] for _ in range(n)]
        
        for i, step in enumerate(steps):
            for dep in step.get("depends_on", []):
                adj[dep].append(i)
                in_degree[i] += 1
        
        levels = []
        current_level = [i for i in range(n) if in_degree[i] == 0]
        
        while current_level:
            levels.append(current_level)
            next_level = []
            
            for node in current_level:
                for neighbor in adj[node]:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        next_level.append(neighbor)
            
            current_level = next_level
        
        return levels
    
    async def broadcast_to_agents(
        self,
        message_type: str,
        payload: Dict[str, Any],
        agent_filter: Optional[Callable[[AgentRegistration], bool]] = None,
    ) -> Dict[str, Any]:
        """Broadcast message to multiple agents"""
        responses = {}
        
        for agent_id, registration in self._agents.items():
            if agent_filter and not agent_filter(registration):
                continue
            
            try:
                if hasattr(registration.instance, 'handle_broadcast'):
                    response = await registration.instance.handle_broadcast(
                        message_type,
                        payload
                    )
                    responses[agent_id] = response
            except Exception as e:
                responses[agent_id] = {"error": str(e)}
        
        return responses
    
    # =========================================================================
    # MONITORING
    # =========================================================================
    
    async def _cleanup_loop(self) -> None:
        """Periodic cleanup of completed tasks"""
        while self._running:
            try:
                await asyncio.sleep(300)  # 5 minutes
                await self._cleanup_old_tasks()
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Cleanup error: {e}")
    
    async def _cleanup_old_tasks(self) -> None:
        """Remove old completed tasks"""
        cutoff = datetime.now(timezone.utc)
        max_age_hours = 24
        
        to_remove = []
        
        for task_id, task in self._tasks.items():
            if task.completed_at:
                age = (cutoff - task.completed_at).total_seconds() / 3600
                if age > max_age_hours:
                    to_remove.append(task_id)
        
        for task_id in to_remove:
            del self._tasks[task_id]
            if task_id in self._task_results:
                del self._task_results[task_id]
        
        if to_remove:
            self.logger.debug(f"Cleaned up {len(to_remove)} old tasks")
    
    async def _monitoring_loop(self) -> None:
        """Monitor agent health and performance"""
        while self._running:
            try:
                await asyncio.sleep(60)
                await self._check_agent_health()
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Monitoring error: {e}")
    
    async def _check_agent_health(self) -> None:
        """Check health of all agents"""
        for agent_id, registration in self._agents.items():
            try:
                if hasattr(registration.instance, 'health_check'):
                    health = await registration.instance.health_check()
                    if not health.get("healthy", True):
                        self.logger.warning(f"Agent {agent_id} is unhealthy: {health}")
            except Exception as e:
                self.logger.error(f"Health check failed for {agent_id}: {e}")
    
    async def health_check(self) -> Dict[str, Any]:
        """Orchestrator health check"""
        return {
            "healthy": self._running,
            "accepting_tasks": self._accepting_tasks,
            "paused": self._paused,
            "registered_agents": len(self._agents),
            "available_agents": len(self.get_available_agents()),
            "pending_tasks": sum(
                1 for t in self._tasks.values()
                if t.state in (TaskState.PENDING, TaskState.QUEUED, TaskState.PROCESSING)
            ),
        }
    
    async def process_task(self, task: Task) -> Dict[str, Any]:
        """Process a task from the queue"""
        await self._route_task(task)
        return await self.get_task_result(task.task_id)
```

---

## ðŸ“„ FILE 11: core/event_bus.py

```python
"""
JAIPI-JUDICIAL V4 Event Bus
Pub/Sub event system for agent communication
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any, Callable, Set
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum, auto
import uuid
from collections import defaultdict


class EventType(Enum):
    """System event types"""
    # System events
    SYSTEM_START = auto()
    SYSTEM_STOP = auto()
    SYSTEM_ERROR = auto()
    SYSTEM_WARNING = auto()
    
    # Agent events
    AGENT_REGISTERED = auto()
    AGENT_UNREGISTERED = auto()
    AGENT_ERROR = auto()
    AGENT_STATE_CHANGE = auto()
    
    # Task events
    TASK_SUBMITTED = auto()
    TASK_STARTED = auto()
    TASK_COMPLETED = auto()
    TASK_FAILED = auto()
    TASK_CANCELLED = auto()
    
    # Watchdog events
    WATCHDOG_ALERT = auto()
    WATCHDOG_VIOLATION = auto()
    WATCHDOG_RESOLUTION = auto()
    
    # Compliance events
    COMPLIANCE_CHECK = auto()
    COMPLIANCE_VIOLATION = auto()
    COMPLIANCE_UPDATE = auto()
    
    # Legal events
    CASE_UPDATE = auto()
    STATUTE_CHANGE = auto()
    REGULATION_CHANGE = auto()
    PRECEDENT_FOUND = auto()
    
    # API events
    API_CALL = auto()
    API_ERROR = auto()
    API_RATE_LIMIT = auto()
    
    # Audit events
    AUDIT_LOG = auto()
    AUDIT_ALERT = auto()
    
    # Notification events
    NOTIFICATION_SENT = auto()
    NOTIFICATION_FAILED = auto()
    
    # Custom events
    CUSTOM = auto()


class EventPriority(Enum):
    """Event priority levels"""
    CRITICAL = 1
    HIGH = 2
    NORMAL = 3
    LOW = 4


@dataclass
class Event:
    """Represents a system event"""
    event_id: str
    event_type: EventType
    source: str
    payload: Dict[str, Any]
    priority: EventPriority = EventPriority.NORMAL
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    correlation_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @classmethod
    def create(
        cls,
        event_type: EventType,
        source: str,
        payload: Dict[str, Any],
        priority: EventPriority = EventPriority.NORMAL,
        correlation_id: Optional[str] = None,
        **metadata,
    ) -> "Event":
        return cls(
            event_id=f"evt_{uuid.uuid4().hex}",
            event_type=event_type,
            source=source,
            payload=payload,
            priority=priority,
            correlation_id=correlation_id,
            metadata=metadata,
        )
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.name,
            "source": self.source,
            "payload": self.payload,
            "priority": self.priority.name,
            "timestamp": self.timestamp.isoformat(),
            "correlation_id": self.correlation_id,
            "metadata": self.metadata,
        }


class Subscription:
    """Event subscription"""
    
    def __init__(
        self,
        subscription_id: str,
        event_types: Set[EventType],
        callback: Callable,
        filter_fn: Optional[Callable[[Event], bool]] = None,
        priority_filter: Optional[Set[EventPriority]] = None,
        source_filter: Optional[Set[str]] = None,
    ):
        self.subscription_id = subscription_id
        self.event_types = event_types
        self.callback = callback
        self.filter_fn = filter_fn
        self.priority_filter = priority_filter
        self.source_filter = source_filter
        self.created_at = datetime.now(timezone.utc)
        self.events_received = 0
        self.errors = 0
    
    def matches(self, event: Event) -> bool:
        """Check if event matches subscription criteria"""
        if event.event_type not in self.event_types:
            return False
        
        if self.priority_filter and event.priority not in self.priority_filter:
            return False
        
        if self.source_filter and event.source not in self.source_filter:
            return False
        
        if self.filter_fn:
            try:
                if not self.filter_fn(event):
                    return False
            except Exception:
                return False
        
        return True


class EventBus:
    """
    Event Bus for JAIPI-JUDICIAL
    
    Features:
    - Async pub/sub event system
    - Event filtering and routing
    - Priority-based event handling
    - Event persistence and replay
    - Dead letter queue for failed events
    """
    
    def __init__(
        self,
        max_queue_size: int = 10000,
        max_history_size: int = 1000,
        enable_persistence: bool = False,
    ):
        self.max_queue_size = max_queue_size
        self.max_history_size = max_history_size
        self.enable_persistence = enable_persistence
        
        # Subscriptions
        self._subscriptions: Dict[str, Subscription] = {}
        self._type_subscriptions: Dict[EventType, Set[str]] = defaultdict(set)
        
        # Event queues
        self._event_queue: asyncio.PriorityQueue = asyncio.PriorityQueue(maxsize=max_queue_size)
        self._dead_letter_queue: List[Event] = []
        
        # Event history
        self._event_history: List[Event] = []
        
        # State
        self._running = False
        self._processor_task: Optional[asyncio.Task] = None
        
        # Metrics
        self._events_published = 0
        self._events_delivered = 0
        self._events_failed = 0
        
        # Synchronization
        self._lock = asyncio.Lock()
        
        # Logging
        self.logger = logging.getLogger(f"{__name__}.EventBus")
    
    @property
    def is_running(self) -> bool:
        return self._running
    
    # =========================================================================
    # LIFECYCLE
    # =========================================================================
    
    async def start(self) -> None:
        """Start the event bus"""
        if self._running:
            return
        
        self.logger.info("Starting Event Bus...")
        self._running = True
        
        # Start event processor
        self._processor_task = asyncio.create_task(self._process_events())
        
        self.logger.info("Event Bus started")
    
    async def stop(self) -> None:
        """Stop the event bus"""
        if not self._running:
            return
        
        self.logger.info("Stopping Event Bus...")
        self._running = False
        
        # Wait for processor to finish
        if self._processor_task:
            self._processor_task.cancel()
            try:
                await self._processor_task
            except asyncio.CancelledError:
                pass
        
        self.logger.info("Event Bus stopped")
    
    # =========================================================================
    # PUBLISHING
    # =========================================================================
    
    async def publish(
        self,
        event_type: EventType,
        source: str,
        payload: Dict[str, Any],
        priority: EventPriority = EventPriority.NORMAL,
        correlation_id: Optional[str] = None,
        **metadata,
    ) -> str:
        """Publish an event"""
        event = Event.create(
            event_type=event_type,
            source=source,
            payload=payload,
            priority=priority,
            correlation_id=correlation_id,
            **metadata,
        )
        
        return await self.publish_event(event)
    
    async def publish_event(self, event: Event) -> str:
        """Publish an existing event object"""
        if not self._running:
            raise RuntimeError("Event bus is not running")
        
        try:
            # Add to queue with priority
            await self._event_queue.put((event.priority.value, event.timestamp.timestamp(), event))
            self._events_published += 1
            
            # Add to history
            await self._add_to_history(event)
            
            return event.event_id
            
        except asyncio.QueueFull:
            self.logger.error(f"Event queue full, dropping event: {event.event_id}")
            self._dead_letter_queue.append(event)
            raise
    
    def publish_sync(
        self,
        event_type: EventType,
        source: str,
        payload: Dict[str, Any],
        priority: EventPriority = EventPriority.NORMAL,
    ) -> str:
        """Synchronous publish (for use outside async context)"""
        event = Event.create(
            event_type=event_type,
            source=source,
            payload=payload,
            priority=priority,
        )
        
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                asyncio.create_task(self.publish_event(event))
            else:
                loop.run_until_complete(self.publish_event(event))
        except RuntimeError:
            # No event loop, store in dead letter queue
            self._dead_letter_queue.append(event)
        
        return event.event_id
    
    # =========================================================================
    # SUBSCRIPTIONS
    # =========================================================================
    
    def subscribe(
        self,
        event_types: Set[EventType],
        callback: Callable,
        filter_fn: Optional[Callable[[Event], bool]] = None,
        priority_filter: Optional[Set[EventPriority]] = None,
        source_filter: Optional[Set[str]] = None,
    ) -> str:
        """Subscribe to events"""
        subscription_id = f"sub_{uuid.uuid4().hex[:12]}"
        
        subscription = Subscription(
            subscription_id=subscription_id,
            event_types=event_types,
            callback=callback,
            filter_fn=filter_fn,
            priority_filter=priority_filter,
            source_filter=source_filter,
        )
        
        self._subscriptions[subscription_id] = subscription
        
        for event_type in event_types:
            self._type_subscriptions[event_type].add(subscription_id)
        
        self.logger.debug(f"Added subscription: {subscription_id} for {[e.name for e in event_types]}")
        
        return subscription_id
    
    def unsubscribe(self, subscription_id: str) -> bool:
        """Unsubscribe from events"""
        if subscription_id not in self._subscriptions:
            return False
        
        subscription = self._subscriptions[subscription_id]
        
        for event_type in subscription.event_types:
            self._type_subscriptions[event_type].discard(subscription_id)
        
        del self._subscriptions[subscription_id]
        
        self.logger.debug(f"Removed subscription: {subscription_id}")
        
        return True
    
    def subscribe_all(
        self,
        callback: Callable,
        filter_fn: Optional[Callable[[Event], bool]] = None,
    ) -> str:
        """Subscribe to all events"""
        return self.subscribe(
            event_types=set(EventType),
            callback=callback,
            filter_fn=filter_fn,
        )
    
    # =========================================================================
    # EVENT PROCESSING
    # =========================================================================
    
    async def _process_events(self) -> None:
        """Main event processing loop"""
        self.logger.debug("Event processor started")
        
        while self._running:
            try:
                # Get next event with timeout
                try:
                    priority, timestamp, event = await asyncio.wait_for(
                        self._event_queue.get(),
                        timeout=1.0
                    )
                except asyncio.TimeoutError:
                    continue
                
                # Deliver event to subscribers
                await self._deliver_event(event)
                
                self._event_queue.task_done()
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Event processing error: {e}")
        
        self.logger.debug("Event processor stopped")
    
    async def _deliver_event(self, event: Event) -> None:
        """Deliver event to matching subscribers"""
        subscription_ids = self._type_subscriptions.get(event.event_type, set())
        
        for subscription_id in subscription_ids:
            subscription = self._subscriptions.get(subscription_id)
            if not subscription:
                continue
            
            if not subscription.matches(event):
                continue
            
            try:
                # Execute callback
                if asyncio.iscoroutinefunction(subscription.callback):
                    await subscription.callback(event)
                else:
                    subscription.callback(event)
                
                subscription.events_received += 1
                self._events_delivered += 1
                
            except Exception as e:
                subscription.errors += 1
                self._events_failed += 1
                self.logger.error(
                    f"Error delivering event {event.event_id} to {subscription_id}: {e}"
                )
    
    # =========================================================================
    # HISTORY & REPLAY
    # =========================================================================
    
    async def _add_to_history(self, event: Event) -> None:
        """Add event to history"""
        async with self._lock:
            self._event_history.append(event)
            
            # Trim history if needed
            if len(self._event_history) > self.max_history_size:
                self._event_history = self._event_history[-self.max_history_size:]
    
    def get_history(
        self,
        event_type: Optional[EventType] = None,
        source: Optional[str] = None,
        since: Optional[datetime] = None,
        limit: int = 100,
    ) -> List[Event]:
        """Get event history"""
        events = self._event_history.copy()
        
        if event_type:
            events = [e for e in events if e.event_type == event_type]
        
        if source:
            events = [e for e in events if e.source == source]
        
        if since:
            events = [e for e in events if e.timestamp >= since]
        
        return events[-limit:]
    
    async def replay_events(
        self,
        subscription_id: str,
        since: Optional[datetime] = None,
        event_types: Optional[Set[EventType]] = None,
    ) -> int:
        """Replay historical events to a subscription"""
        subscription = self._subscriptions.get(subscription_id)
        if not subscription:
            raise ValueError(f"Unknown subscription: {subscription_id}")
        
        events = self.get_history(since=since)
        
        if event_types:
            events = [e for e in events if e.event_type in event_types]
        
        count = 0
        for event in events:
            if subscription.matches(event):
                try:
                    if asyncio.iscoroutinefunction(subscription.callback):
                        await subscription.callback(event)
                    else:
                        subscription.callback(event)
                    count += 1
                except Exception as e:
                    self.logger.error(f"Error replaying event: {e}")
        
        return count
    
    # =========================================================================
    # UTILITIES
    # =========================================================================
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get event bus metrics"""
        return {
            "running": self._running,
            "subscriptions": len(self._subscriptions),
            "queue_size": self._event_queue.qsize(),
            "history_size": len(self._event_history),
            "dead_letter_size": len(self._dead_letter_queue),
            "events_published": self._events_published,
            "events_delivered": self._events_delivered,
            "events_failed": self._events_failed,
        }
    
    def get_dead_letters(self, limit: int = 100) -> List[Event]:
        """Get dead letter queue contents"""
        return self._dead_letter_queue[-limit:]
    
    async def retry_dead_letters(self) -> int:
        """Retry events in dead letter queue"""
        count = 0
        while self._dead_letter_queue:
            event = self._dead_letter_queue.pop(0)
            try:
                await self.publish_event(event)
                count += 1
            except Exception:
                self._dead_letter_queue.append(event)
                break
        return count
```

---

## ðŸ“„ FILE 12: agents/__init__.py

```python
"""
JAIPI-JUDICIAL V4 Agents Package
Complete collection of specialized legal and government watchdog agents
"""

from .base_agent import BaseAgent, AgentCapability
from .watchdog_agent import WatchdogAgent
from .compliance_agent import ComplianceAgent
from .citation_agent import CitationAgent
from .precedent_agent import PrecedentAgent
from .statutory_agent import StatutoryAgent
from .constitutional_agent import ConstitutionalAgent
from .regulatory_agent import RegulatoryAgent
from .procedural_agent import ProceduralAgent
from .evidence_agent import EvidenceAgent
from .sentiment_agent import SentimentAgent
from .risk_agent import RiskAgent
from .audit_agent import AuditAgent
from .notification_agent import NotificationAgent
from .coordination_agent import CoordinationAgent
from .foia_agent import FOIAAgent
from .ethics_agent import EthicsAgent
from .jurisdiction_agent import JurisdictionAgent
from .timeline_agent import TimelineAgent
from .document_agent import DocumentAgent
from .api_monitor_agent import APIMonitorAgent
from .budget_agent import BudgetAgent
from .transparency_agent import TransparencyAgent
from .whistleblower_agent import WhistleblowerAgent
from .contract_agent import ContractAgent
from .administrative_agent import AdministrativeAgent
from .enforcement_agent import EnforcementAgent
from .appeals_agent import AppealsAgent
from .legislative_agent import LegislativeAgent
from .emergency_agent import EmergencyAgent

__all__ = [
    # Base
    "BaseAgent",
    "AgentCapability",
    
    # Core Agents
    "WatchdogAgent",
    "ComplianceAgent",
    "AuditAgent",
    "NotificationAgent",
    "CoordinationAgent",
    
    # Legal Analysis Agents
    "CitationAgent",
    "PrecedentAgent",
    "StatutoryAgent",
    "ConstitutionalAgent",
    "RegulatoryAgent",
    "ProceduralAgent",
    "JurisdictionAgent",
    "AppealsAgent",
    
    # Document & Evidence Agents
    "DocumentAgent",
    "EvidenceAgent",
    "TimelineAgent",
    
    # Analysis Agents
    "SentimentAgent",
    "RiskAgent",
    
    # Government Oversight Agents
    "FOIAAgent",
    "EthicsAgent",
    "TransparencyAgent",
    "BudgetAgent",
    "WhistleblowerAgent",
    "APIMonitorAgent",
    
    # Specialized Agents
    "ContractAgent",
    "AdministrativeAgent",
    "EnforcementAgent",
    "LegislativeAgent",
    "EmergencyAgent",
]

# Agent registry for dynamic lookup
AGENT_REGISTRY = {
    "watchdog": WatchdogAgent,
    "compliance": ComplianceAgent,
    "citation": CitationAgent,
    "precedent": PrecedentAgent,
    "statutory": StatutoryAgent,
    "constitutional": ConstitutionalAgent,
    "regulatory": RegulatoryAgent,
    "procedural": ProceduralAgent,
    "evidence": EvidenceAgent,
    "sentiment": SentimentAgent,
    "risk": RiskAgent,
    "audit": AuditAgent,
    "notification": NotificationAgent,
    "coordination": CoordinationAgent,
    "foia": FOIAAgent,
    "ethics": EthicsAgent,
    "jurisdiction": JurisdictionAgent,
    "timeline": TimelineAgent,
    "document": DocumentAgent,
    "api_monitor": APIMonitorAgent,
    "budget": BudgetAgent,
    "transparency": TransparencyAgent,
    "whistleblower": WhistleblowerAgent,
    "contract": ContractAgent,
    "administrative": AdministrativeAgent,
    "enforcement": EnforcementAgent,
    "appeals": AppealsAgent,
    "legislative": LegislativeAgent,
    "emergency": EmergencyAgent,
}


def get_agent_class(agent_type: str):
    """Get agent class by type name"""
    return AGENT_REGISTRY.get(agent_type.lower())
```

---

## ðŸ“„ FILE 13: agents/base_agent.py

```python
"""
JAIPI-JUDICIAL V4 Base Agent
Foundation class for all specialized agents
"""

import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum, auto
import uuid

from config.constants import AgentConstants


class AgentCapability(Enum):
    """Agent capabilities"""
    TEXT_ANALYSIS = auto()
    DOCUMENT_PROCESSING = auto()
    CITATION_EXTRACTION = auto()
    LEGAL_RESEARCH = auto()
    COMPLIANCE_CHECK = auto()
    RISK_ASSESSMENT = auto()
    API_INTEGRATION = auto()
    DATABASE_QUERY = auto()
    NOTIFICATION = auto()
    AUDIT_LOGGING = auto()
    REAL_TIME_MONITORING = auto()
    MACHINE_LEARNING = auto()
    NLP = auto()
    ENTITY_EXTRACTION = auto()
    RELATIONSHIP_MAPPING = auto()
    TIMELINE_ANALYSIS = auto()
    BUDGET_ANALYSIS = auto()
    WORKFLOW_COORDINATION = auto()


@dataclass
class AgentMetrics:
    """Agent performance metrics"""
    tasks_processed: int = 0
    tasks_successful: int = 0
    tasks_failed: int = 0
    total_processing_time: float = 0.0
    average_processing_time: float = 0.0
    last_activity: Optional[datetime] = None
    errors: List[Dict[str, Any]] = field(default_factory=list)
    
    def record_task(self, success: bool, processing_time: float) -> None:
        self.tasks_processed += 1
        if success:
            self.tasks_successful += 1
        else:
            self.tasks_failed += 1
        self.total_processing_time += processing_time
        self.average_processing_time = self.total_processing_time / self.tasks_processed
        self.last_activity = datetime.now(timezone.utc)
    
    @property
    def success_rate(self) -> float:
        if self.tasks_processed == 0:
            return 1.0
        return self.tasks_successful / self.tasks_processed


class BaseAgent(ABC):
    """
    Base Agent Class
    
    All JAIPI agents inherit from this class and implement:
    - Initialization and shutdown
    - Task execution
    - Health monitoring
    - Event handling
    - State management
    """
    
    # Class-level attributes (override in subclasses)
    agent_name: str = "BaseAgent"
    agent_description: str = "Base agent class"
    supported_task_types: Set[str] = set()
    capabilities: Set[AgentCapability] = set()
    
    def __init__(
        self,
        agent_id: str,
        orchestrator: Any,
        event_bus: Any,
        cache_manager: Any,
        config: Dict[str, Any],
    ):
        self.agent_id = agent_id
        self.orchestrator = orchestrator
        self.event_bus = event_bus
        self.cache_manager = cache_manager
        self.config = config
        
        # State
        self._state = AgentConstants.AgentState.INITIALIZING
        self._priority = AgentConstants.Priority.MEDIUM
        self._metrics = AgentMetrics()
        
        # Internal state
        self._current_task: Optional[Any] = None
        self._lock = asyncio.Lock()
        self._shutdown_event = asyncio.Event()
        
        # Logging
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        
        # Event subscriptions
        self._subscriptions: List[str] = []
    
    @property
    def state(self) -> AgentConstants.AgentState:
        return self._state
    
    @property
    def priority(self) -> AgentConstants.Priority:
        return self._priority
    
    @property
    def metrics(self) -> AgentMetrics:
        return self._metrics
    
    @property
    def is_available(self) -> bool:
        return (
            self._state == AgentConstants.AgentState.IDLE
            and self._current_task is None
        )
    
    # =========================================================================
    # LIFECYCLE METHODS
    # =========================================================================
    
    async def initialize(self) -> None:
        """Initialize the agent"""
        self.logger.info(f"Initializing agent: {self.agent_id}")
        
        try:
            # Subscribe to relevant events
            await self._setup_subscriptions()
            
            # Load any required resources
            await self._load_resources()
            
            # Agent-specific initialization
            await self.on_initialize()
            
            self._state = AgentConstants.AgentState.IDLE
            self.logger.info(f"Agent {self.agent_id} initialized successfully")
            
        except Exception as e:
            self._state = AgentConstants.AgentState.ERROR
            self.logger.error(f"Agent initialization failed: {e}")
            raise
    
    async def shutdown(self) -> None:
        """Shutdown the agent"""
        self.logger.info(f"Shutting down agent: {self.agent_id}")
        
        self._state = AgentConstants.AgentState.TERMINATED
        self._shutdown_event.set()
        
        # Unsubscribe from events
        for subscription_id in self._subscriptions:
            self.event_bus.unsubscribe(subscription_id)
        
        # Agent-specific cleanup
        await self.on_shutdown()
        
        self.logger.info(f"Agent {self.agent_id} shutdown complete")
    
    @abstractmethod
    async def on_initialize(self) -> None:
        """Agent-specific initialization (override in subclasses)"""
        pass
    
    async def on_shutdown(self) -> None:
        """Agent-specific cleanup (override in subclasses)"""
        pass
    
    async def _setup_subscriptions(self) -> None:
        """Setup event subscriptions"""
        # Override in subclasses to subscribe to specific events
        pass
    
    async def _load_resources(self) -> None:
        """Load required resources"""
        # Override in subclasses to load models, data, etc.
        pass
    
    # =========================================================================
    # TASK EXECUTION
    # =========================================================================
    
    async def execute(self, task: Any) -> Dict[str, Any]:
        """Execute a task"""
        if self._state != AgentConstants.AgentState.IDLE:
            raise RuntimeError(f"Agent not available (state: {self._state})")
        
        async with self._lock:
            self._state = AgentConstants.AgentState.PROCESSING
            self._current_task = task
            start_time = datetime.now(timezone.utc)
            
            try:
                # Pre-execution hook
                await self.before_execute(task)
                
                # Main execution
                result = await self.process_task(task)
                
                # Post-execution hook
                result = await self.after_execute(task, result)
                
                # Record success
                elapsed = (datetime.now(timezone.utc) - start_time).total_seconds()
                self._metrics.record_task(success=True, processing_time=elapsed)
                
                return result
                
            except Exception as e:
                # Record failure
                elapsed = (datetime.now(timezone.utc) - start_time).total_seconds()
                self._metrics.record_task(success=False, processing_time=elapsed)
                self._metrics.errors.append({
                    "task_id": task.task_id if hasattr(task, 'task_id') else None,
                    "error": str(e),
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                })
                
                # Error handling hook
                await self.on_error(task, e)
                raise
                
            finally:
                self._current_task = None
                self._state = AgentConstants.AgentState.IDLE
    
    @abstractmethod
    async def process_task(self, task: Any) -> Dict[str, Any]:
        """Process a task (implement in subclasses)"""
        pass
    
    async def before_execute(self, task: Any) -> None:
        """Pre-execution hook"""
        pass
    
    async def after_execute(self, task: Any, result: Dict[str, Any]) -> Dict[str, Any]:
        """Post-execution hook"""
        return result
    
    async def on_error(self, task: Any, error: Exception) -> None:
        """Error handling hook"""
        self.logger.error(f"Task error in {self.agent_id}: {error}")
    
    # =========================================================================
    # EVENT HANDLING
    # =========================================================================
    
    async def handle_event(self, event: Any) -> None:
        """Handle incoming events"""
        # Override in subclasses
        pass
    
    async def handle_broadcast(
        self,
        message_type: str,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Handle broadcast messages from orchestrator"""
        return {"received": True, "agent_id": self.agent_id}
    
    async def emit_event(
        self,
        event_type: Any,
        payload: Dict[str, Any],
        priority: Any = None,
    ) -> str:
        """Emit an event"""
        from core.event_bus import EventPriority
        
        return await self.event_bus.publish(
            event_type=event_type,
            source=self.agent_id,
            payload=payload,
            priority=priority or EventPriority.NORMAL,
        )
    
    # =========================================================================
    # INTER-AGENT COMMUNICATION
    # =========================================================================
    
    async def request_agent(
        self,
        task_type: str,
        payload: Dict[str, Any],
        timeout: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Request another agent to perform a task"""
        task_id = await self.orchestrator.submit_task(
            task_type=task_type,
            payload=payload,
            priority=self._priority,
            timeout=timeout,
        )
        return await self.orchestrator.get_task_result(task_id, timeout=timeout)
    
    async def coordinate_with(
        self,
        agent_ids: List[str],
        message: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Coordinate with specific agents"""
        responses = {}
        
        for agent_id in agent_ids:
            agent = self.orchestrator.get_agent(agent_id)
            if agent and hasattr(agent, 'handle_coordination'):
                try:
                    response = await agent.handle_coordination(self.agent_id, message)
                    responses[agent_id] = response
                except Exception as e:
                    responses[agent_id] = {"error": str(e)}
        
        return responses
    
    async def handle_coordination(
        self,
        from_agent: str,
        message: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Handle coordination request from another agent"""
        return {"acknowledged": True}
    
    # =========================================================================
    # CACHING
    # =========================================================================
    
    async def cache_get(self, key: str) -> Optional[Any]:
        """Get value from cache"""
        return await self.cache_manager.get(f"{self.agent_id}:{key}")
    
    async def cache_set(
        self,
        key: str,
        value: Any,
        ttl: Optional[int] = None,
    ) -> None:
        """Set value in cache"""
        await self.cache_manager.set(f"{self.agent_id}:{key}", value, ttl=ttl)
    
    async def cache_delete(self, key: str) -> None:
        """Delete value from cache"""
        await self.cache_manager.delete(f"{self.agent_id}:{key}")
    
    # =========================================================================
    # HEALTH & MONITORING
    # =========================================================================
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform health check"""
        return {
            "healthy": self._state not in (
                AgentConstants.AgentState.ERROR,
                AgentConstants.AgentState.TERMINATED
            ),
            "agent_id": self.agent_id,
            "state": self._state.name,
            "available": self.is_available,
            "metrics": {
                "tasks_processed": self._metrics.tasks_processed,
                "success_rate": self._metrics.success_rate,
                "average_processing_time": self._metrics.average_processing_time,
                "last_activity": (
                    self._metrics.last_activity.isoformat()
                    if self._metrics.last_activity else None
                ),
            },
        }
    
    def get_status(self) -> Dict[str, Any]:
        """Get current status"""
        return {
            "agent_id": self.agent_id,
            "agent_name": self.agent_name,
            "state": self._state.name,
            "priority": self._priority.name,
            "capabilities": [c.name for c in self.capabilities],
            "task_types": list(self.supported_task_types),
            "current_task": (
                self._current_task.task_id
                if self._current_task and hasattr(self._current_task, 'task_id')
                else None
            ),
            "metrics": {
                "tasks_processed": self._metrics.tasks_processed,
                "tasks_successful": self._metrics.tasks_successful,
                "tasks_failed": self._metrics.tasks_failed,
                "success_rate": self._metrics.success_rate,
            },
        }
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def log_activity(
        self,
        action: str,
        details: Optional[Dict[str, Any]] = None,
    ) -> None:
        """Log agent activity"""
        self.logger.info(
            f"[{self.agent_id}] {action}",
            extra={"details": details or {}},
        )
    
    async def wait_for_shutdown(self) -> None:
        """Wait for shutdown signal"""
        await self._shutdown_event.wait()
```

---

## ðŸ“„ FILE 14: agents/watchdog_agent.py

```python
"""
JAIPI-JUDICIAL V4 Watchdog Agent
Primary government API and law monitoring agent
"""

import asyncio
from typing import Dict, List, Optional, Any, Set
from datetime import datetime, timezone, timedelta
from dataclasses import dataclass, field
from enum import Enum, auto

from .base_agent import BaseAgent, AgentCapability
from config.constants import AgentConstants
from core.event_bus import EventType, EventPriority


class AlertSeverity(Enum):
    """Alert severity levels"""
    CRITICAL = 1
    HIGH = 2
    MEDIUM = 3
    LOW = 4
    INFORMATIONAL = 5


class AlertCategory(Enum):
    """Categories of watchdog alerts"""
    API_ANOMALY = auto()
    COMPLIANCE_VIOLATION = auto()
    DATA_INCONSISTENCY = auto()
    UNAUTHORIZED_ACCESS = auto()
    RATE_LIMIT_EXCEEDED = auto()
    SERVICE_DEGRADATION = auto()
    LEGAL_CHANGE = auto()
    REGULATORY_UPDATE = auto()
    BUDGET_ANOMALY = auto()
    TRANSPARENCY_ISSUE = auto()
    SECURITY_THREAT = auto()
    PROCESS_VIOLATION = auto()


@dataclass
class WatchdogAlert:
    """Represents a watchdog alert"""
    alert_id: str
    severity: AlertSeverity
    category: AlertCategory
    title: str
    description: str
    source: str
    detected_at: datetime
    evidence: Dict[str, Any] = field(default_factory=dict)
    affected_entities: List[str] = field(default_factory=list)
    recommended_actions: List[str] = field(default_factory=list)
    acknowledged: bool = False
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "alert_id": self.alert_id,
            "severity": self.severity.name,
            "category": self.category.name,
            "title": self.title,
            "description": self.description,
            "source": self.source,
            "detected_at": self.detected_at.isoformat(),
            "evidence": self.evidence,
            "affected_entities": self.affected_entities,
            "recommended_actions": self.recommended_actions,
            "acknowledged": self.acknowledged,
            "resolved": self.resolved,
            "resolved_at": self.resolved_at.isoformat() if self.resolved_at else None,
        }


@dataclass
class MonitoringRule:
    """Defines a monitoring rule"""
    rule_id: str
    name: str
    description: str
    category: AlertCategory
    severity: AlertSeverity
    condition: str  # Expression to evaluate
    threshold: Optional[float] = None
    time_window_minutes: int = 60
    enabled: bool = True
    cooldown_minutes: int = 15
    last_triggered: Optional[datetime] = None


class WatchdogAgent(BaseAgent):
    """
    Watchdog Agent
    
    Primary monitoring agent for:
    - Government API compliance
    - Legal and regulatory changes
    - Data integrity and consistency
    - Access patterns and anomalies
    - Budget and spending anomalies
    - Transparency requirements
    - Security threats
    
    Acts as the central nervous system for detecting
    violations, anomalies, and important changes.
    """
    
    agent_name = "WatchdogAgent"
    agent_description = "Primary government API and law monitoring agent"
    supported_task_types = {
        "watchdog_scan",
        "watchdog_alert",
        "watchdog_rule_check",
        "watchdog_report",
        "api_health_check",
        "compliance_scan",
        "anomaly_detection",
    }
    capabilities = {
        AgentCapability.REAL_TIME_MONITORING,
        AgentCapability.API_INTEGRATION,
        AgentCapability.COMPLIANCE_CHECK,
        AgentCapability.RISK_ASSESSMENT,
        AgentCapability.AUDIT_LOGGING,
        AgentCapability.NOTIFICATION,
    }
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Configuration
        self.scan_interval = self.config.get("interval", 60)  # seconds
        self.alert_threshold = self.config.get("alert_threshold", 0.7)
        self.max_alerts_per_hour = self.config.get("max_alerts_per_hour", 100)
        
        # State
        self._alerts: Dict[str, WatchdogAlert] = {}
        self._rules: Dict[str, MonitoringRule] = {}
        self._monitoring_task: Optional[asyncio.Task] = None
        self._alert_counts: Dict[str, int] = {}  # hour -> count
        
        # Metrics
        self._scans_performed = 0
        self._alerts_generated = 0
        self._violations_detected = 0
    
    async def on_initialize(self) -> None:
        """Initialize watchdog agent"""
        # Load default monitoring rules
        await self._load_default_rules()
        
        # Start monitoring loop
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())
        
        self.logger.info(f"Watchdog agent initialized with {len(self._rules)} rules")
    
    async def on_shutdown(self) -> None:
        """Shutdown watchdog agent"""
        if self._monitoring_task:
            self._monitoring_task.cancel()
            try:
                await self._monitoring_task
            except asyncio.CancelledError:
                pass
    
    async def _setup_subscriptions(self) -> None:
        """Subscribe to relevant events"""
        from core.event_bus import EventType
        
        subscription_id = self.event_bus.subscribe(
            event_types={
                EventType.API_CALL,
                EventType.API_ERROR,
                EventType.COMPLIANCE_VIOLATION,
                EventType.STATUTE_CHANGE,
                EventType.REGULATION_CHANGE,
                EventType.AUDIT_ALERT,
            },
            callback=self.handle_event,
        )
        self._subscriptions.append(subscription_id)
    
    # =========================================================================
    # TASK PROCESSING
    # =========================================================================
    
    async def process_task(self, task: Any) -> Dict[str, Any]:
        """Process watchdog tasks"""
        task_type = task.task_type
        payload = task.payload
        
        if task_type == "watchdog_scan":
            return await self._perform_scan(payload)
        
        elif task_type == "watchdog_alert":
            return await self._handle_alert_task(payload)
        
        elif task_type == "watchdog_rule_check":
            return await self._check_rule(payload)
        
        elif task_type == "watchdog_report":
            return await self._generate_report(payload)
        
        elif task_type == "api_health_check":
            return await self._check_api_health(payload)
        
        elif task_type == "compliance_scan":
            return await self._scan_compliance(payload)
        
        elif task_type == "anomaly_detection":
            return await self._detect_anomalies(payload)
        
        else:
            raise ValueError(f"Unknown task type: {task_type}")
    
    # =========================================================================
    # MONITORING LOOP
    # =========================================================================
    
    async def _monitoring_loop(self) -> None:
        """Main monitoring loop"""
        self.logger.info("Watchdog monitoring loop started")
        
        while not self._shutdown_event.is_set():
            try:
                await asyncio.sleep(self.scan_interval)
                
                # Perform periodic scans
                await self._perform_periodic_scan()
                
                # Check all rules
                await self._check_all_rules()
                
                # Clean up old alerts
                await self._cleanup_old_alerts()
                
                self._scans_performed += 1
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Monitoring loop error: {e}")
                await asyncio.sleep(5)  # Brief pause on error
        
        self.logger.info("Watchdog monitoring loop stopped")
    
    async def _perform_periodic_scan(self) -> None:
        """Perform periodic system scan"""
        scan_results = {
            "api_health": await self._scan_api_health(),
            "compliance_status": await self._scan_compliance_status(),
            "anomalies": await self._scan_for_anomalies(),
            "pending_changes": await self._scan_pending_changes(),
        }
        
        # Process scan results
        for category, results in scan_results.items():
            if results.get("alerts"):
                for alert_data in results["alerts"]:
                    await self._create_alert(alert_data)
    
    # =========================================================================
    # SCANNING FUNCTIONS
    # =========================================================================
    
    async def _perform_scan(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Perform a targeted scan"""
        scan_type = payload.get("scan_type", "full")
        target = payload.get("target")
        
        results = {
            "scan_type": scan_type,
            "target": target,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "findings": [],
            "alerts": [],
        }
        
        if scan_type == "full":
            results["findings"].extend(await self._full_system_scan())
        elif scan_type == "api":
            results["findings"].extend(await self._scan_api_endpoints(target))
        elif scan_type == "compliance":
            results["findings"].extend(await self._scan_compliance_target(target))
        elif scan_type == "security":
            results["findings"].extend(await self._scan_security(target))
        
        # Generate alerts from findings
        for finding in results["findings"]:
            if finding.get("severity_score", 0) >= self.alert_threshold:
                alert = await self._create_alert_from_finding(finding)
                results["alerts"].append(alert.to_dict())
        
        return results
    
    async def _scan_api_health(self) -> Dict[str, Any]:
        """Scan health of monitored APIs"""
        from config.api_endpoints import GovernmentAPIEndpoints
        
        results = {
            "healthy": [],
            "degraded": [],
            "down": [],
            "alerts": [],
        }
        
        endpoints = GovernmentAPIEndpoints.get_active_endpoints()
        
        for endpoint in endpoints[:10]:  # Limit for performance
            try:
                health = await self._check_endpoint_health(endpoint)
                
                if health["status"] == "healthy":
                    results["healthy"].append(endpoint.name)
                elif health["status"] == "degraded":
                    results["degraded"].append(endpoint.name)
                    results["alerts"].append({
                        "category": AlertCategory.SERVICE_DEGRADATION,
                        "severity": AlertSeverity.MEDIUM,
                        "title": f"API Degradation: {endpoint.name}",
                        "description": f"API {endpoint.name} is experiencing degraded performance",
                        "evidence": health,
                    })
                else:
                    results["down"].append(endpoint.name)
                    results["alerts"].append({
                        "category": AlertCategory.SERVICE_DEGRADATION,
                        "severity": AlertSeverity.HIGH,
                        "title": f"API Down: {endpoint.name}",
                        "description": f"API {endpoint.name} is not responding",
                        "evidence": health,
                    })
                    
            except Exception as e:
                self.logger.warning(f"Failed to check {endpoint.name}: {e}")
        
        return results
    
    async def _check_endpoint_health(self, endpoint: Any) -> Dict[str, Any]:
        """Check health of a single endpoint"""
        # Simulated health check - in production, make actual HTTP requests
        import random
        
        status = random.choices(
            ["healthy", "degraded", "down"],
            weights=[0.9, 0.08, 0.02]
        )[0]
        
        return {
            "endpoint": endpoint.name,
            "status": status,
            "response_time_ms": random.randint(50, 500) if status != "down" else None,
            "checked_at": datetime.now(timezone.utc).isoformat(),
        }
    
    async def _scan_compliance_status(self) -> Dict[str, Any]:
        """Scan overall compliance status"""
        results = {
            "compliant": 0,
            "non_compliant": 0,
            "pending_review": 0,
            "alerts": [],
        }
        
        # Request compliance data from compliance agent
        try:
            compliance_data = await self.request_agent(
                task_type="compliance_summary",
                payload={"scope": "all"},
                timeout=30,
            )
            
            results.update(compliance_data)
            
            # Generate alerts for non-compliant items
            if compliance_data.get("violations"):
                for violation in compliance_data["violations"]:
                    results["alerts"].append({
                        "category": AlertCategory.COMPLIANCE_VIOLATION,
                        "severity": AlertSeverity.HIGH,
                        "title": f"Compliance Violation: {violation.get('code', 'Unknown')}",
                        "description": violation.get("description", ""),
                        "evidence": violation,
                    })
                    
        except Exception as e:
            self.logger.warning(f"Failed to get compliance status: {e}")
        
        return results
    
    async def _scan_for_anomalies(self) -> Dict[str, Any]:
        """Scan for system anomalies"""
        results = {
            "anomalies_detected": 0,
            "alerts": [],
        }
        
        # Check various anomaly indicators
        anomaly_checks = [
            self._check_rate_anomalies(),
            self._check_data_anomalies(),
            self._check_access_anomalies(),
            self._check_budget_anomalies(),
        ]
        
        for check in await asyncio.gather(*anomaly_checks, return_exceptions=True):
            if isinstance(check, Exception):
                self.logger.warning(f"Anomaly check failed: {check}")
                continue
            
            if check.get("anomaly_detected"):
                results["anomalies_detected"] += 1
                results["alerts"].append(check.get("alert"))
        
        return results
    
    async def _check_rate_anomalies(self) -> Dict[str, Any]:
        """Check for rate limit anomalies"""
        # Implementation would check API rate patterns
        return {"anomaly_detected": False}
    
    async def _check_data_anomalies(self) -> Dict[str, Any]:
        """Check for data consistency anomalies"""
        # Implementation would check data patterns
        return {"anomaly_detected": False}
    
    async def _check_access_anomalies(self) -> Dict[str, Any]:
        """Check for unusual access patterns"""
        # Implementation would check access logs
        return {"anomaly_detected": False}
    
    async def _check_budget_anomalies(self) -> Dict[str, Any]:
        """Check for budget-related anomalies"""
        # Implementation would check spending patterns
        return {"anomaly_detected": False}
    
    async def _scan_pending_changes(self) -> Dict[str, Any]:
        """Scan for pending legal/regulatory changes"""
        results = {
            "pending_legislation": [],
            "pending_regulations": [],
            "alerts": [],
        }
        
        # Request data from legislative agent
        try:
            legislative_data = await self.request_agent(
                task_type="pending_legislation",
                payload={"importance": "high"},
                timeout=30,
            )
            results["pending_legislation"] = legislative_data.get("bills", [])
            
        except Exception as e:
            self.logger.warning(f"Failed to get legislative data: {e}")
        
        # Request data from regulatory agent
        try:
            regulatory_data = await self.request_agent(
                task_type="pending_regulations",
                payload={"status": "proposed"},
                timeout=30,
            )
            results["pending_regulations"] = regulatory_data.get("regulations", [])
            
        except Exception as e:
            self.logger.warning(f"Failed to get regulatory data: {e}")
        
        # Generate alerts for important changes
        for item in results["pending_legislation"][:5]:
            if item.get("impact_score", 0) > 0.8:
                results["alerts"].append({
                    "category": AlertCategory.LEGAL_CHANGE,
                    "severity": AlertSeverity.MEDIUM,
                    "title": f"High-Impact Legislation: {item.get('bill_id', 'Unknown')}",
                    "description": item.get("title", ""),
                    "evidence": item,
                })
        
        return results
    
    async def _full_system_scan(self) -> List[Dict[str, Any]]:
        """Perform full system scan"""
        findings = []
        
        # Aggregate all scan results
        scans = await asyncio.gather(
            self._scan_api_health(),
            self._scan_compliance_status(),
            self._scan_for_anomalies(),
            self._scan_pending_changes(),
            return_exceptions=True,
        )
        
        for scan in scans:
            if isinstance(scan, Exception):
                findings.append({
                    "type": "scan_error",
                    "error": str(scan),
                    "severity_score": 0.5,
                })
            elif scan.get("alerts"):
                for alert in scan["alerts"]:
                    findings.append({
                        "type": alert.get("category", AlertCategory.API_ANOMALY).name,
                        "details": alert,
                        "severity_score": self._severity_to_score(
                            alert.get("severity", AlertSeverity.MEDIUM)
                        ),
                    })
        
        return findings
    
    def _severity_to_score(self, severity: AlertSeverity) -> float:
        """Convert severity to numeric score"""
        mapping = {
            AlertSeverity.CRITICAL: 1.0,
            AlertSeverity.HIGH: 0.8,
            AlertSeverity.MEDIUM: 0.6,
            AlertSeverity.LOW: 0.4,
            AlertSeverity.INFORMATIONAL: 0.2,
        }
        return mapping.get(severity, 0.5)
    
    # =========================================================================
    # ALERT MANAGEMENT
    # =========================================================================
    
    async def _create_alert(self, alert_data: Dict[str, Any]) -> WatchdogAlert:
        """Create and store a new alert"""
        import uuid
        
        alert = WatchdogAlert(
            alert_id=f"alert_{uuid.uuid4().hex[:12]}",
            severity=alert_data.get("severity", AlertSeverity.MEDIUM),
            category=alert_data.get("category", AlertCategory.API_ANOMALY),
            title=alert_data.get("title", "Unknown Alert"),
            description=alert_data.get("description", ""),
            source=self.agent_id,
            detected_at=datetime.now(timezone.utc),
            evidence=alert_data.get("evidence", {}),
            affected_entities=alert_data.get("affected_entities", []),
            recommended_actions=alert_data.get("recommended_actions", []),
        )
        
        # Store alert
        self._alerts[alert.alert_id] = alert
        self._alerts_generated += 1
        
        # Emit event
        await self.emit_event(
            event_type=EventType.WATCHDOG_ALERT,
            payload=alert.to_dict(),
            priority=self._alert_to_event_priority(alert.severity),
        )
        
        # Trigger notification for critical/high alerts
        if alert.severity in (AlertSeverity.CRITICAL, AlertSeverity.HIGH):
            await self._notify_alert(alert)
        
        self.logger.warning(
            f"Alert created: [{alert.severity.name}] {alert.title}"
        )
        
        return alert
    
    async def _create_alert_from_finding(
        self,
        finding: Dict[str, Any],
    ) -> WatchdogAlert:
        """Create alert from a scan finding"""
        details = finding.get("details", {})
        
        return await self._create_alert({
            "severity": details.get("severity", AlertSeverity.MEDIUM),
            "category": AlertCategory[finding.get("type", "API_ANOMALY")],
            "title": details.get("title", finding.get("type", "Finding")),
            "description": details.get("description", str(finding)),
            "evidence": finding,
        })
    
    def _alert_to_event_priority(self, severity: AlertSeverity) -> EventPriority:
        """Convert alert severity to event priority"""
        mapping = {
            AlertSeverity.CRITICAL: EventPriority.CRITICAL,
            AlertSeverity.HIGH: EventPriority.HIGH,
            AlertSeverity.MEDIUM: EventPriority.NORMAL,
            AlertSeverity.LOW: EventPriority.LOW,
            AlertSeverity.INFORMATIONAL: EventPriority.LOW,
        }
        return mapping.get(severity, EventPriority.NORMAL)
    
    async def _notify_alert(self, alert: WatchdogAlert) -> None:
        """Send notification for critical alert"""
        try:
            await self.request_agent(
                task_type="send_notification",
                payload={
                    "type": "alert",
                    "alert": alert.to_dict(),
                    "channels": ["email", "slack"] if alert.severity == AlertSeverity.CRITICAL else ["slack"],
                },
                timeout=10,
            )
        except Exception as e:
            self.logger.error(f"Failed to send alert notification: {e}")
    
    async def acknowledge_alert(self, alert_id: str) -> bool:
        """Acknowledge an alert"""
        if alert_id not in self._alerts:
            return False
        
        self._alerts[alert_id].acknowledged = True
        return True
    
    async def resolve_alert(
        self,
        alert_id: str,
        resolution_notes: Optional[str] = None,
    ) -> bool:
        """Resolve an alert"""
        if alert_id not in self._alerts:
            return False
        
        alert = self._alerts[alert_id]
        alert.resolved = True
        alert.resolved_at = datetime.now(timezone.utc)
        
        # Emit resolution event
        await self.emit_event(
            event_type=EventType.WATCHDOG_RESOLUTION,
            payload={
                "alert_id": alert_id,
                "resolution_notes": resolution_notes,
                "resolved_at": alert.resolved_at.isoformat(),
            },
        )
        
        return True
    
    async def _cleanup_old_alerts(self) -> None:
        """Clean up old resolved alerts"""
        cutoff = datetime.now(timezone.utc) - timedelta(days=7)
        
        to_remove = [
            alert_id for alert_id, alert in self._alerts.items()
            if alert.resolved and alert.resolved_at and alert.resolved_at < cutoff
        ]
        
        for alert_id in to_remove:
            del self._alerts[alert_id]
    
    # =========================================================================
    # RULE MANAGEMENT
    # =========================================================================
    
    async def _load_default_rules(self) -> None:
        """Load default monitoring rules"""
        default_rules = [
            MonitoringRule(
                rule_id="rule_api_error_rate",
                name="API Error Rate",
                description="Alert when API error rate exceeds threshold",
                category=AlertCategory.API_ANOMALY,
                severity=AlertSeverity.HIGH,
                condition="error_rate > threshold",
                threshold=0.1,  # 10% error rate
                time_window_minutes=15,
            ),
            MonitoringRule(
                rule_id="rule_compliance_violation",
                name="Compliance Violation",
                description="Alert on any compliance violation",
                category=AlertCategory.COMPLIANCE_VIOLATION,
                severity=AlertSeverity.CRITICAL,
                condition="violation_detected",
                time_window_minutes=5,
            ),
            MonitoringRule(
                rule_id="rule_rate_limit",
                name="Rate Limit Warning",
                description="Alert when approaching rate limits",
                category=AlertCategory.RATE_LIMIT_EXCEEDED,
                severity=AlertSeverity.MEDIUM,
                condition="rate_usage > threshold",
                threshold=0.8,  # 80% of limit
                time_window_minutes=60,
            ),
            MonitoringRule(
                rule_id="rule_unauthorized_access",
                name="Unauthorized Access Attempt",
                description="Alert on unauthorized access attempts",
                category=AlertCategory.UNAUTHORIZED_ACCESS,
                severity=AlertSeverity.CRITICAL,
                condition="unauthorized_access_detected",
                time_window_minutes=1,
            ),
            MonitoringRule(
                rule_id="rule_budget_anomaly",
                name="Budget Anomaly",
                description="Alert on unusual spending patterns",
                category=AlertCategory.BUDGET_ANOMALY,
                severity=AlertSeverity.HIGH,
                condition="spending_deviation > threshold",
                threshold=2.0,  # 2 standard deviations
                time_window_minutes=1440,  # 24 hours
            ),
            MonitoringRule(
                rule_id="rule_legal_change",
                name="Significant Legal Change",
                description="Alert on significant legal changes",
                category=AlertCategory.LEGAL_CHANGE,
                severity=AlertSeverity.MEDIUM,
                condition="impact_score > threshold",
                threshold=0.7,
                time_window_minutes=60,
            ),
        ]
        
        for rule in default_rules:
            self._rules[rule.rule_id] = rule
    
    async def _check_all_rules(self) -> None:
        """Check all monitoring rules"""
        for rule_id, rule in self._rules.items():
            if not rule.enabled:
                continue
            
            # Check cooldown
            if rule.last_triggered:
                cooldown_end = rule.last_triggered + timedelta(minutes=rule.cooldown_minutes)
                if datetime.now(timezone.utc) < cooldown_end:
                    continue
            
            try:
                triggered = await self._evaluate_rule(rule)
                if triggered:
                    rule.last_triggered = datetime.now(timezone.utc)
            except Exception as e:
                self.logger.error(f"Error checking rule {rule_id}: {e}")
    
    async def _evaluate_rule(self, rule: MonitoringRule) -> bool:
        """Evaluate a single monitoring rule"""
        # This would contain actual rule evaluation logic
        # For now, return False (no trigger)
        return False
    
    async def _check_rule(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Check a specific rule"""
        rule_id = payload.get("rule_id")
        
        if rule_id not in self._rules:
            return {"error": f"Unknown rule: {rule_id}"}
        
        rule = self._rules[rule_id]
        triggered = await self._evaluate_rule(rule)
        
        return {
            "rule_id": rule_id,
            "rule_name": rule.name,
            "triggered": triggered,
            "checked_at": datetime.now(timezone.utc).isoformat(),
        }
    
    # =========================================================================
    # REPORTING
    # =========================================================================
    
    async def _generate_report(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Generate watchdog report"""
        report_type = payload.get("type", "summary")
        time_range = payload.get("time_range_hours", 24)
        
        cutoff = datetime.now(timezone.utc) - timedelta(hours=time_range)
        
        recent_alerts = [
            alert.to_dict() for alert in self._alerts.values()
            if alert.detected_at >= cutoff
        ]
        
        report = {
            "report_type": report_type,
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "time_range_hours": time_range,
            "summary": {
                "total_alerts": len(recent_alerts),
                "critical_alerts": sum(1 for a in recent_alerts if a["severity"] == "CRITICAL"),
                "high_alerts": sum(1 for a in recent_alerts if a["severity"] == "HIGH"),
                "resolved_alerts": sum(1 for a in recent_alerts if a["resolved"]),
                "unacknowledged_alerts": sum(1 for a in recent_alerts if not a["acknowledged"]),
            },
            "by_category": {},
            "alerts": recent_alerts if report_type == "detailed" else [],
            "metrics": {
                "scans_performed": self._scans_performed,
                "total_alerts_generated": self._alerts_generated,
                "violations_detected": self._violations_detected,
            },
        }
        
        # Group by category
        for alert in recent_alerts:
            category = alert["category"]
            if category not in report["by_category"]:
                report["by_category"][category] = 0
            report["by_category"][category] += 1
        
        return report
    
    # =========================================================================
    # EVENT HANDLING
    # =========================================================================
    
    async def handle_event(self, event: Any) -> None:
        """Handle incoming events"""
        if event.event_type == EventType.API_ERROR:
            await self._handle_api_error(event)
        elif event.event_type == EventType.COMPLIANCE_VIOLATION:
            await self._handle_compliance_violation(event)
        elif event.event_type in (EventType.STATUTE_CHANGE, EventType.REGULATION_CHANGE):
            await self._handle_legal_change(event)
    
    async def _handle_api_error(self, event: Any) -> None:
        """Handle API error event"""
        # Track error patterns
        payload = event.payload
        
        # Check if this warrants an alert
        if payload.get("consecutive_errors", 0) >= 3:
            await self._create_alert({
                "category": AlertCategory.API_ANOMALY,
                "severity": AlertSeverity.HIGH,
                "title": f"Repeated API Errors: {payload.get('endpoint', 'Unknown')}",
                "description": f"API endpoint experiencing repeated errors",
                "evidence": payload,
            })
    
    async def _handle_compliance_violation(self, event: Any) -> None:
        """Handle compliance violation event"""
        self._violations_detected += 1
        
        await self._create_alert({
            "category": AlertCategory.COMPLIANCE_VIOLATION,
            "severity": AlertSeverity.CRITICAL,
            "title": f"Compliance Violation Detected",
            "description": event.payload.get("description", ""),
            "evidence": event.payload,
            "affected_entities": event.payload.get("affected_entities", []),
        })
    
    async def _handle_legal_change(self, event: Any) -> None:
        """Handle legal/regulatory change event"""
        payload = event.payload
        
        if payload.get("impact_score", 0) >= 0.7:
            await self._create_alert({
                "category": AlertCategory.LEGAL_CHANGE if event.event_type == EventType.STATUTE_CHANGE else AlertCategory.REGULATORY_UPDATE,
                "severity": AlertSeverity.MEDIUM,
                "title": f"Legal Change: {payload.get('title', 'Unknown')}",
                "description": payload.get("summary", ""),
                "evidence": payload,
            })
    
    # =========================================================================
    # ADDITIONAL TASK HANDLERS
    # =========================================================================
    
    async def _handle_alert_task(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Handle alert-related tasks"""
        action = payload.get("action")
        alert_id = payload.get("alert_id")
        
        if action == "acknowledge":
            success = await self.acknowledge_alert(alert_id)
            return {"success": success, "action": "acknowledge", "alert_id": alert_id}
        
        elif action == "resolve":
            success = await self.resolve_alert(
                alert_id,
                resolution_notes=payload.get("notes"),
            )
            return {"success": success, "action": "resolve", "alert_id": alert_id}
        
        elif action == "list":
            severity_filter = payload.get("severity")
            category_filter = payload.get("category")
            
            alerts = list(self._alerts.values())
            
            if severity_filter:
                alerts = [a for a in alerts if a.severity.name == severity_filter]
            if category_filter:
                alerts = [a for a in alerts if a.category.name == category_filter]
            
            return {
                "alerts": [a.to_dict() for a in alerts],
                "total": len(alerts),
            }
        
        elif action == "get":
            alert = self._alerts.get(alert_id)
            if alert:
                return {"alert": alert.to_dict()}
            return {"error": f"Alert not found: {alert_id}"}
        
        return {"error": f"Unknown action: {action}"}
    
    async def _check_api_health(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Check API health task"""
        target = payload.get("target")  # Specific API or "all"
        
        if target and target != "all":
            from config.api_endpoints import GovernmentAPIEndpoints
            endpoint = GovernmentAPIEndpoints.get_endpoint_by_name(target)
            if endpoint:
                health = await self._check_endpoint_health(endpoint)
                return {"endpoint": target, "health": health}
            return {"error": f"Unknown endpoint: {target}"}
        
        return await self._scan_api_health()
    
    async def _scan_compliance(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Scan compliance task"""
        return await self._scan_compliance_status()
    
    async def _detect_anomalies(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """Detect anomalies task"""
        anomaly_type = payload.get("type", "all")
        
        if anomaly_type == "all":
            return await self._scan_for_anomalies()
        elif anomaly_type == "rate":
            return await self._check_rate_anomalies()
        elif anomaly_type == "data":
            return await self._check_data_anomalies()
        elif anomaly_type == "access":
            return await self._check_access_anomalies()
        elif anomaly_type == "budget":
            return await self._check_budget_anomalies()
        
        return {"error": f"Unknown anomaly type: {anomaly_type}"}
    
    async def _scan_api_endpoints(self, target: Optional[str]) -> List[Dict[str, Any]]:
        """Scan specific API endpoints"""
        results = await self._scan_api_health()
        findings = []
        
        for alert in results.get("alerts", []):
            findings.append({
                "type": "API_ANOMALY",
                "details": alert,
                "severity_score": self._severity_to_score(alert.get("severity", AlertSeverity.MEDIUM)),
            })
        
        return findings
    
    async def _scan_compliance_target(self, target: Optional[str]) -> List[Dict[str, Any]]:
        """Scan compliance for specific target"""
        results = await self._scan_compliance_status()
        findings = []
        
        for alert in results.get("alerts", []):
            findings.append({
                "type": "COMPLIANCE_VIOLATION",
                "details": alert,
                "severity_score": self._severity_to_score(alert.get("severity", AlertSeverity.HIGH)),
            })
        
        return findings
    
    async def _scan_security(self, target: Optional[str]) -> List[Dict[str, Any]]:
        """Scan security"""
        # Security scanning implementation
        return []
```

---

## ðŸ“„ FILE 15: agents/compliance_agent.py

```python
"""
JAIPI-JUDICIAL V4 Compliance Agent
Monitors and enforces compliance with legal and regulatory requirements
"""

import asyncio
from typing import Dict, List, Optional, Any, Set
from datetime import datetime, timezone, timedelta
from dataclasses import dataclass, field
from enum import Enum, auto

from .base_agent import BaseAgent, AgentCapability
from config.constants import AgentConstants, ComplianceConstants


class ComplianceStatus(Enum):
    """Compliance status values"""
    COMPLIANT = "compliant"
    NON_COMPLIANT = "non_compliant"
    PARTIAL = "partial"
    PENDING_REVIEW = "pending_review"
    WAIVER_GRANTED = "waiver_granted"
    NOT_APPLICABLE = "not_applicable"
    UNDER_INVESTIGATION = "under_investigation"


class ComplianceFramework(Enum):
    """Compliance frameworks"""
    APA = "Administrative Procedure Act"
    FOIA = "Freedom of Information Act"
    FACA = "Federal Advisory Committee Act"
    PRA = "Paperwork Reduction Act"
    DATA_ACT = "Digital Accountability and Transparency Act"
    FITARA = "Federal IT Acquisition Reform Act"
    FISMA = "Federal Information Security Management Act"
    HIPAA = "Health Insurance Portability and Accountability Act"
    FERPA = "Family Educational Rights and Privacy Act"
    ADA = "Americans with Disabilities Act"
    SECTION_508 = "Section 508 Accessibility"
    FRA = "Federal Records Act"
    GPRA = "Government Performance and Results Act"


@dataclass
class ComplianceRequirement:
    """Represents a compliance requirement"""
    requirement_id: str
    framework: ComplianceFramework
    title: str
    description: str
    citation: str
    check_type: str  # "automated", "manual", "hybrid"
    severity: str  # "critical", "high", "medium", "low"
    check_frequency_days: int = 30
    last_checked: Optional[datetime] = None
    
    def is_due_for_check(self) -> bool:
        if not self.last_checked:
            return True
        next_check = self.last_checked + timedelta(days=self.check_frequency_days)
        return datetime.now(timezone.utc) >= next_check


@dataclass
class ComplianceCheck:
    """Result of a compliance check"""
    check_id: str
    requirement_id: str
    status: ComplianceStatus
    checked_at: datetime
    checked_by: str
    findings: List[Dict[str, Any]] = field(default_factory=list)
    evidence: Dict[str, Any] = field(default_factory=dict)
    remediation_required: bool = False
    remediation_deadline: Optional[datetime] = None
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "check_id": self.check_id,
            "requirement_id": self.requirement_id,
            "status": self.status.value,
            "checked_at": self.checked_at.isoformat(),
            "checked_by": self.checked_by,
            "findings": self.findings,
            "evidence": self.evidence,
            "remediation_required": self.remediation_required,
            "remediation_deadline": (
                self.remediation_deadline.isoformat()
                if self.remediation_deadline else None
            ),
            "notes": self.notes,
        }


@dataclass
class ComplianceViolation:
    """Represents a compliance violation"""
    violation_id: str
    requirement_id: str
    framework: ComplianceFramework
    severity: str
    title: str
    description: str
    detected_at: datetime
    affected_entities: List[str] = field(default_factory=list)
    evidence: Dict[str, Any] = field(default_factory=dict)
    status: str = "open"  # open, investigating, remediated, closed
    remediation_plan: Optional[str] = None
    remediated_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "violation_id": self.violation_id,
            "requirement_id": self.requirement_id,
            "framework": self.framework.value,
            "severity": self.severity,
            "title": self.title,
            "description": self.description,
            "detected_at": self.detected_at.isoformat(),
            "affected_entities": self.affected_entities,
            "evidence": self.evidence,
            "status": self.status,
            "remediation_plan": self.remediation_plan,
            "remediated_at": self.remediated_at.isoformat() if self.remediated_at else None,
        }


class ComplianceAgent(BaseAgent):
    """
    Compliance Agent
    
    Monitors and enforces compliance with:
    - Administrative Procedure Act (APA)
    - Freedom of Information Act (FOIA)
    - Federal records management
    - Data transparency requirements
    - Accessibility standards (Section 508)
    - Information security (FISMA)
    - Various other regulatory frameworks
    
    Provides:
    - Automated compliance checking
    - Violation detection and tracking
    - Remediation workflow support
    - Compliance reporting and dashboards
    """
    
    agent_name = "ComplianceAgent"
    agent_description = "Monitors and enforces legal and regulatory compliance"
    supported_task_types = {
        "compliance_check",
        "compliance_scan",
        "compliance_summary",
        "violation_report",
        "remediation_status",
        "framework_audit",
        "compliance_score",
    }
    capabilities = {
        AgentCapability.COMPLIANCE_CHECK,
        AgentCapability.AUDIT_LOGGING,
        AgentCapability.RISK_ASSESSMENT,
        AgentCapability.DATABASE_QUERY,
        AgentCapability.NOTIFICATION,
    }
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        # Configuration
        self.auto_check_enabled = self.config.get("auto_check", True)
        self.check_interval_hours = self.config.get("check_interval_hours", 24)
        
        # State
        self._requirements: Dict[str, ComplianceRequirement] = {}
        self._checks: Dict[str, ComplianceCheck] = {}
        self._violations: Dict[str, ComplianceViolation] = {}
        self._check_task: Optional[asyncio.Task] = None
    
    async def on_initialize(self) -> None:
        """Initialize compliance agent"""
        # Load compliance requirements
        await self._load_requirements()
        
        # Start periodic checking if enabled
        if self.auto_check_enabled:
            self._check_task = asyncio.create_task(self._periodic_check_loop())
        
        self.logger.info(
            f"Compliance agent initialized with {len(self._requirements)} requirements"
        )
    
    async def on_shutdown(self) -> None:
        """Shutdown compliance agent"""
        if self._check_task:
            self._check_task.cancel()
            try:
                await self._check_task
            except asyncio.CancelledError:
                pass
    
    async def _load_requirements(self) -> None:
        """Load compliance requirements"""
        # APA Requirements
        apa_requirements = [
            ComplianceRequirement(
                requirement_id="APA_001",
                framework=ComplianceFramework.APA,
                title="Notice and Comment Rulemaking",
                description="Agencies must provide notice of proposed rulemaking and allow public comment",
                citation="5 U.S.C. Â§ 553",
                check_type="automated",
                severity="critical",
                check_frequency_days=7,
            ),
            ComplianceRequirement(
                requirement_id="APA_002",
                framework=ComplianceFramework.APA,
                title="Publication of Rules",
                description="Final rules must be published in the Federal Register",
                citation="5 U.S.C. Â§ 552(a)(1)",
                check_type="automated",
                severity="high",
                check_frequency_days=1,
            ),
            ComplianceRequirement(
                requirement_id="APA_003",
                framework=ComplianceFramework.APA,
                title="Adjudication Procedures",
                description="Agency adjudications must follow proper procedures",
                citation="5 U.S.C. Â§Â§ 554-557",
                check_type="manual",
                severity="high",
                check_frequency_days=30,
            ),
        ]
        
        # FOIA Requirements
        foia_requirements = [
            ComplianceRequirement(
                requirement_id="FOIA_001",
                framework=ComplianceFramework.FOIA,
                title="Response Time Limits",
                description="FOIA requests must be responded to within 20 business days",
                citation="5 U.S.C. Â§ 552(a)(6)(A)",
                check_type="automated",
                severity="high",
                check_frequency_days=1,
            ),
            ComplianceRequirement(
                requirement_id="FOIA_002",
                framework=ComplianceFramework.FOIA,
                title="Proactive Disclosure",
                description="Frequently requested records must be proactively disclosed",
                citation="5 U.S.C. Â§ 552(a)(2)",
                check_type="hybrid",
                severity="medium",
                check_frequency_days=30,
            ),
            ComplianceRequirement(
                requirement_id="FOIA_003",
                framework=ComplianceFramework.FOIA,
                title="Fee Waivers",
                description="Fee waivers must be properly evaluated",
                citation="5 U.S.C. Â§ 552(a)(4)(A)",
                check_type="manual",
                severity="medium",
                check_frequency_days=30,
            ),
        ]
        
        # DATA Act Requirements
        data_act_requirements = [
            ComplianceRequirement(
                requirement_id="DATA_001",
                framework=ComplianceFramework.DATA_ACT,
                title="Spending Data Quality",
                description="Federal spending data must be accurate and complete",
                citation="31 U.S.C. Â§ 6101 note",
                check_type="automated",
                severity="high",
                check_frequency_days=7,
            ),
            ComplianceRequirement(
                requirement_id="DATA_002",
                framework=ComplianceFramework.DATA_ACT,
                title="USAspending Submission",
                description="Spending data must be submitted to USAspending.gov",
                citation="31 U.S.C. Â§ 6101 note",
                check_type="automated",
                severity="critical",
                check_frequency_days=1,
            ),
        ]
        
        # Section 508 Requirements
        accessibility_requirements = [
            ComplianceRequirement(
                requirement_id="508_001",
                framework=ComplianceFramework.SECTION_508,
                title="Web Accessibility",
                description="Public-facing websites must be accessible",
                citation="29 U.S.C. Â§ 794d",
                check_type="automated",
                severity="high",
                check_frequency_days=30,
            ),
            ComplianceRequirement(
                requirement_id="508_002",
                framework=ComplianceFramework.SECTION_508,
                title="Document Accessibility",
                description="Electronic documents must be accessible",
                citation="29 U.S.C. Â§ 794d",
                check_type="hybrid",
                severity="medium",
                check_frequency_days=30,
            ),
        ]
        
        # FISMA Requirements
        security_requirements = [
            ComplianceRequirement(
                requirement_id="FISMA_001",
                framework=ComplianceFramework.FISMA,
                title="Security Assessment",
                description="Information systems must undergo security assessment",
                citation="44 U.S.C. Â§ 3554",
                check_type="manual",
                severity="critical",
                check_frequency_days=365,
            ),
            ComplianceRequirement(
                requirement_id="FISMA_002",
                framework=ComplianceFramework.FISMA,
                title="Incident Reporting",
                description="Security incidents must be reported",
                citation="44 U.S.C. Â§ 3554(b)(7)",
                check_type="automated",
                severity="critical",
                check_frequency_days=1,
            ),
        ]
        
        # Store all requirements
        all_requirements = (
            apa_requirements +
            foia_requirements +
            data_act_requirements +
            accessibility_requirements +
            security_requirements
        )
        
        for req in all_requirements:
            self._requirements[req.requirement_id] = req
    
    # =========================================================================
    # TASK PROCESSING
    # =========================================================================
    
    async def process_task(self, task: Any) -> Dict[str, Any]:
        """Process compliance tasks"""
        task_type = task.task_type
        payload = task.payload
        
        if task_type == "compliance_check":
            return await self._perform_compliance_check(payload)
        
        elif task_type == "compliance_scan":
            return await self._perform_compliance_scan(payload)
        
        elif task_type == "compliance_summary":
            return await self._get_compliance_summary(payload)
        
        elif task_type == "violation_report":
            return await self._get_violation_report(payload)
        
        elif task_type == "remediation_status":
            return await self._get_remediation_status(payload)
        
        elif task_type == "framework_audit":
            return await self._perform_framework_audit(payload)
        
        elif task_type == "compliance_score":
            return await self._calculate_compliance_score(payload)
        
        else:
            raise ValueError(f"Unknown task type: {task_type}")
    
    # =========================================================================
    # COMPLIANCE CHECKING
    # =========================================================================
    
    async def _periodic_check_loop(self) -> None:
        """Periodic compliance check loop"""
        while not self._shutdown_event.is_set():
            try:
                await asyncio.sleep(self.check_interval_hours * 3600)
                await self._run_due_checks()
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Periodic check error: {e}")
    
    async def _run_due_checks(self) -> None:
        """Run all due compliance checks"""
        due_requirements = [
            req for req in self._requirements.values()
            if req.is_due_for_check() and req.check_type in ("automated", "hybrid")
        ]
        
        for req in due_requirements:
            try:
                await self._check_requirement(req)
            except Exception as e:
                self.logger.error(f"Error checking {req.requirement_id}: {e}")
    
    async def _perform_compliance_check(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Perform a specific compliance check"""
        requirement_id = payload.get("requirement_id")
        target = payload.get("target")
        
        if requirement_id and requirement_id in self._requirements:
            req = self._requirements[requirement_id]
            check = await self._check_requirement(req, target)
            return check.to_dict()
        
        elif requirement_id:
            return {"error": f"Unknown requirement: {requirement_id}"}
        
        # Check all requirements for target
        results = []
        for req in self._requirements.values():
            if req.check_type in ("automated", "hybrid"):
                check = await self._check_requirement(req, target)
                results.append(check.to_dict())
        
        return {
            "target": target,
            "checks": results,
            "total": len(results),
            "compliant": sum(1 for r in results if r["status"] == "compliant"),
            "non_compliant": sum(1 for r in results if r["status"] == "non_compliant"),
        }
    
    async def _check_requirement(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str] = None,
    ) -> ComplianceCheck:
        """Check a single compliance requirement"""
        import uuid
        
        check_id = f"check_{uuid.uuid4().hex[:12]}"
        
        # Perform the actual check based on requirement type
        if requirement.framework == ComplianceFramework.FOIA:
            result = await self._check_foia_compliance(requirement, target)
        elif requirement.framework == ComplianceFramework.APA:
            result = await self._check_apa_compliance(requirement, target)
        elif requirement.framework == ComplianceFramework.DATA_ACT:
            result = await self._check_data_act_compliance(requirement, target)
        elif requirement.framework == ComplianceFramework.SECTION_508:
            result = await self._check_accessibility_compliance(requirement, target)
        elif requirement.framework == ComplianceFramework.FISMA:
            result = await self._check_security_compliance(requirement, target)
        else:
            result = await self._check_generic_compliance(requirement, target)
        
        # Create check record
        check = ComplianceCheck(
            check_id=check_id,
            requirement_id=requirement.requirement_id,
            status=result["status"],
            checked_at=datetime.now(timezone.utc),
            checked_by=self.agent_id,
            findings=result.get("findings", []),
            evidence=result.get("evidence", {}),
            remediation_required=result["status"] == ComplianceStatus.NON_COMPLIANT,
            notes=result.get("notes", ""),
        )
        
        # Set remediation deadline if needed
        if check.remediation_required:
            if requirement.severity == "critical":
                check.remediation_deadline = datetime.now(timezone.utc) + timedelta(days=7)
            elif requirement.severity == "high":
                check.remediation_deadline = datetime.now(timezone.utc) + timedelta(days=30)
            else:
                check.remediation_deadline = datetime.now(timezone.utc) + timedelta(days=90)
        
        # Store check
        self._checks[check_id] = check
        
        # Update requirement last checked
        requirement.last_checked = datetime.now(timezone.utc)
        
        # Create violation if non-compliant
        if check.status == ComplianceStatus.NON_COMPLIANT:
            await self._create_violation(requirement, check)
        
        return check
    
    async def _check_foia_compliance(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str],
    ) -> Dict[str, Any]:
        """Check FOIA compliance"""
        # Implementation would check actual FOIA data
        
        if requirement.requirement_id == "FOIA_001":
            # Check response time compliance
            # In production, query FOIA request database
            return {
                "status": ComplianceStatus.COMPLIANT,
                "findings": [],
                "evidence": {
                    "average_response_days": 15,
                    "overdue_requests": 0,
                    "checked_requests": 100,
                },
                "notes": "All FOIA requests within time limits",
            }
        
        return {
            "status": ComplianceStatus.COMPLIANT,
            "findings": [],
            "evidence": {},
        }
    
    async def _check_apa_compliance(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str],
    ) -> Dict[str, Any]:
        """Check APA compliance"""
        if requirement.requirement_id == "APA_002":
            # Check Federal Register publication
            # In production, query Federal Register API
            return {
                "status": ComplianceStatus.COMPLIANT,
                "findings": [],
                "evidence": {
                    "rules_published": 50,
                    "pending_publication": 2,
                },
            }
        
        return {
            "status": ComplianceStatus.COMPLIANT,
            "findings": [],
            "evidence": {},
        }
    
    async def _check_data_act_compliance(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str],
    ) -> Dict[str, Any]:
        """Check DATA Act compliance"""
        # Implementation would check USAspending data quality
        return {
            "status": ComplianceStatus.COMPLIANT,
            "findings": [],
            "evidence": {
                "data_quality_score": 0.95,
                "submission_status": "current",
            },
        }
    
    async def _check_accessibility_compliance(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str],
    ) -> Dict[str, Any]:
        """Check Section 508 accessibility compliance"""
        # Implementation would run accessibility scans
        return {
            "status": ComplianceStatus.PARTIAL,
            "findings": [
                {
                    "issue": "Missing alt text on images",
                    "severity": "medium",
                    "count": 5,
                },
            ],
            "evidence": {
                "pages_scanned": 100,
                "issues_found": 5,
                "wcag_level": "AA",
            },
        }
    
    async def _check_security_compliance(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str],
    ) -> Dict[str, Any]:
        """Check FISMA security compliance"""
        return {
            "status": ComplianceStatus.COMPLIANT,
            "findings": [],
            "evidence": {
                "last_assessment_date": "2025-06-15",
                "risk_level": "low",
            },
        }
    
    async def _check_generic_compliance(
        self,
        requirement: ComplianceRequirement,
        target: Optional[str],
    ) -> Dict[str, Any]:
        """Generic compliance check"""
        return {
            "status": ComplianceStatus.PENDING_REVIEW,
            "findings": [],
            "evidence": {},
            "notes": "Manual review required",
        }
    
    # =========================================================================
    # VIOLATION MANAGEMENT
    # =========================================================================
    
    async def _create_violation(
        self,
        requirement: ComplianceRequirement,
        check: ComplianceCheck,
    ) -> ComplianceViolation:
        """Create a compliance violation"""
        import uuid
        from core.event_bus import EventType
        
        violation = ComplianceViolation(
            violation_id=f"viol_{uuid.uuid4().hex[:12]}",
            requirement_id=requirement.requirement_id,
            framework=requirement.framework,
            severity=requirement.severity,
            title=f"Violation: {requirement.title}",
            description=f"Non-compliance detected for {requirement.title}",
            detected_at=datetime.now(timezone.utc),
            evidence=check.evidence,
        )
        
        self._violations[violation.violation_id] = violation
        
        # Emit compliance violation event
        await self.emit_event(
            event_type=EventType.COMPLIANCE_VIOLATION,
            payload=violation.to_dict(),
        )
        
        self.logger.warning(
            f"Compliance violation created: {violation.violation_id} - {violation.title}"
        )
        
        return violation
    
    # =========================================================================
    # REPORTING
    # =========================================================================
    
    async def _perform_compliance_scan(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Perform a full compliance scan"""
        framework_filter = payload.get("framework")
        
        requirements = list(self._requirements.values())
        
        if framework_filter:
            framework = ComplianceFramework(framework_filter)
            requirements = [r for r in requirements if r.framework == framework]
        
        results = []
        for req in requirements:
            if req.check_type in ("automated", "hybrid"):
                check = await self._check_requirement(req)
                results.append(check.to_dict())
        
        return {
            "scan_type": "compliance",
            "framework_filter": framework_filter,
            "scanned_at": datetime.now(timezone.utc).isoformat(),
            "total_requirements": len(requirements),
            "checks_performed": len(results),
            "results": results,
            "summary": {
                "compliant": sum(1 for r in results if r["status"] == "compliant"),
                "non_compliant": sum(1 for r in results if r["status"] == "non_compliant"),
                "partial": sum(1 for r in results if r["status"] == "partial"),
                "pending_review": sum(1 for r in results if r["status"] == "pending_review"),
            },
        }
    
    async def _get_compliance_summary(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Get compliance summary"""
        scope = payload.get("scope", "all")
        
        # Get recent checks
        recent_checks = sorted(
            self._checks.values(),
            key=lambda c: c.checked_at,
            reverse=True,
        )[:100]
        
        # Get open violations
        open_violations = [
            v.to_dict() for v in self._violations.values()
            if v.status in ("open", "investigating")
        ]
        
        # Calculate summary stats
        by_status = {}
        for check in recent_checks:
            status = check.status.value
            if status not in by_status:
                by_status[status] = 0
            by_status[status] += 1
        
        by_framework = {}
        for req_id, check in [(c.requirement_id, c) for c in recent_checks]:
            if req_id in self._requirements:
                framework = self._requirements[req_id].framework.value
                if framework not in by_framework:
                    by_framework[framework] = {"compliant": 0, "non_compliant": 0}
                if check.status == ComplianceStatus.COMPLIANT:
                    by_framework[framework]["compliant"] += 1
                elif check.status == ComplianceStatus.NON_COMPLIANT:
                    by_framework[framework]["non_compliant"] += 1
        
        return {
            "summary_date": datetime.now(timezone.utc).isoformat(),
            "scope": scope,
            "total_requirements": len(self._requirements),
            "recent_checks": len(recent_checks),
            "by_status": by_status,
            "by_framework": by_framework,
            "open_violations": len(open_violations),
            "violations": open_violations[:10],  # Top 10
            "compliance_rate": (
                by_status.get("compliant", 0) / len(recent_checks)
                if recent_checks else 1.0
            ),
        }
    
    async def _get_violation_report(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Get violation report"""
        status_filter = payload.get("status")
        framework_filter = payload.get("framework")
        
        violations = list(self._violations.values())
        
        if status_filter:
            violations = [v for v in violations if v.status == status_filter]
        
        if framework_filter:
            framework = ComplianceFramework(framework_filter)
            violations = [v for v in violations if v.framework == framework]
        
        return {
            "report_date": datetime.now(timezone.utc).isoformat(),
            "filters": {
                "status": status_filter,
                "framework": framework_filter,
            },
            "total_violations": len(violations),
            "by_severity": {
                "critical": sum(1 for v in violations if v.severity == "critical"),
                "high": sum(1 for v in violations if v.severity == "high"),
                "medium": sum(1 for v in violations if v.severity == "medium"),
                "low": sum(1 for v in violations if v.severity == "low"),
            },
            "violations": [v.to_dict() for v in violations],
        }
    
    async def _get_remediation_status(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Get remediation status"""
        violation_id = payload.get("violation_id")
        
        if violation_id:
            if violation_id in self._violations:
                violation = self._violations[violation_id]
                return {
                    "violation": violation.to_dict(),
                    "remediation_status": violation.status,
                    "remediation_plan": violation.remediation_plan,
                }
            return {"error": f"Unknown violation: {violation_id}"}
        
        # Get all violations requiring remediation
        requiring_remediation = [
            v.to_dict() for v in self._violations.values()
            if v.status in ("open", "investigating")
        ]
        
        overdue = [
            v for v in requiring_remediation
            # In production, check against deadlines
        ]
        
        return {
            "total_requiring_remediation": len(requiring_remediation),
            "overdue": len(overdue),
            "violations": requiring_remediation,
        }
    
    async def _perform_framework_audit(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Perform audit of specific framework"""
        framework_name = payload.get("framework")
        
        if not framework_name:
            return {"error": "Framework not specified"}
        
        try:
            framework = ComplianceFramework(framework_name)
        except ValueError:
            return {"error": f"Unknown framework: {framework_name}"}
        
        # Get all requirements for framework
        requirements = [
            r for r in self._requirements.values()
            if r.framework == framework
        ]
        
        # Check all requirements
        results = []
        for req in requirements:
            check = await self._check_requirement(req)
            results.append({
                "requirement": {
                    "id": req.requirement_id,
                    "title": req.title,
                    "citation": req.citation,
                    "severity": req.severity,
                },
                "check": check.to_dict(),
            })
        
        compliant = sum(1 for r in results if r["check"]["status"] == "compliant")
        
        return {
            "audit_date": datetime.now(timezone.utc).isoformat(),
            "framework": framework.value,
            "total_requirements": len(requirements),
            "results": results,
            "compliance_rate": compliant / len(requirements) if requirements else 1.0,
            "summary": {
                "compliant": compliant,
                "non_compliant": sum(1 for r in results if r["check"]["status"] == "non_compliant"),
                "partial": sum(1 for r in results if r["check"]["status"] == "partial"),
            },
        }
    
    async def _calculate_compliance_score(
        self,
        payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Calculate overall compliance score"""
        # Weight by severity
        severity_weights = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1,
        }
        
        total_weight = 0
        compliant_weight = 0
        
        for check in self._checks.values():
            if check.requirement_id in self._requirements:
                req = self._requirements[check.requirement_id]
                weight = severity_weights.get(req.severity, 1)
                total_weight += weight
                
                if check.status == ComplianceStatus.COMPLIANT:
                    compliant_weight += weight
                elif check.status == ComplianceStatus.PARTIAL:
                    compliant_weight += weight * 0.5
        
        score = (compliant_weight / total_weight * 100) if total_weight > 0 else 100
        
        # Determine grade
        if score >= 95:
            grade = "A"
        elif score >= 85:
            grade = "B"
        elif score >= 75:
            grade = "C"
        elif score >= 65:
            grade = "D"
        else:
            grade = "F"
        
        return {
            "score": round(score, 2),
            "grade": grade,
            "total_weight": total_weight,
            "compliant_weight": compliant_weight,
            "calculated_at": datetime.now(timezone.utc).isoformat(),
            "breakdown": {
                "critical_compliance": self._get_severity_compliance("critical"),
                "high_compliance": self._get_severity_compliance("high"),
                "medium_compliance": self._get_severity_compliance("medium"),
                "low_compliance": self._get_severity_compliance("low"),
            },
        }
    
    def _get_severity_compliance(self, severity: str) -> float:
        """Get compliance rate for specific severity"""
        relevant_reqs = [
            r.requirement_id for r in self._requirements.values()
            if r.severity == severity
        ]
        
        if not relevant_reqs:
            return 1.0
        
        compliant = 0
        total = 0
        
        for check in self._checks.values():
            if check.requirement_id in relevant_reqs:
                total += 1
                if check.status == ComplianceStatus.COMPLIANT:
                    compliant += 1
        
        return compliant / total if total > 0 else 1.0
```

---

Let me continue with more agent implementations and the remaining system components...

## ðŸ“„ FILE 16: algorithms/__init__.py

```python
"""
JAIPI-JUDICIAL V4 Algorithms Package
Core algorithms for legal analysis and processing
"""

from .legal_reasoning import LegalReasoningEngine
from .precedent_matching import PrecedentMatcher
from .compliance_scoring import ComplianceScoringEngine
from .risk_assessment import RiskAssessmentEngine
from .anomaly_detection import AnomalyDetector
from .text_classification import LegalTextClassifier
from .entity_extraction import LegalEntityExtractor
from .relationship_mapping import RelationshipMapper
from .timeline_reconstruction import TimelineReconstructor
from .budget_analysis import BudgetAnalyzer
from .network_analysis import NetworkAnalyzer
from .predictive_models import LegalPredictiveModels

__all__ = [
    "LegalReasoningEngine",
    "PrecedentMatcher",
    "ComplianceScoringEngine",
    "RiskAssessmentEngine",
    "AnomalyDetector",
    "LegalTextClassifier",
    "LegalEntityExtractor",
    "RelationshipMapper",
    "TimelineReconstructor",
    "BudgetAnalyzer",
    "NetworkAnalyzer",
    "LegalPredictiveModels",
]
```

---

## ðŸ“„ FILE 17: algorithms/legal_reasoning.py

```python
"""
JAIPI-JUDICIAL V4 Legal Reasoning Engine
Core algorithm for legal analysis and reasoning
"""

from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
import asyncio
import logging


class ReasoningType(Enum):
    """Types of legal reasoning"""
    DEDUCTIVE = auto()  # From general rules to specific conclusions
    INDUCTIVE = auto()  # From specific cases to general principles
    ANALOGICAL = auto()  # From similar cases
    POLICY_BASED = auto()  # Based on policy considerations
    TEXTUAL = auto()  # Based on statutory text
    PURPOSIVE = auto()  # Based on legislative intent
    PRECEDENTIAL = auto()  # Based on prior decisions


class ArgumentStrength(Enum):
    """Strength of legal arguments"""
    CONCLUSIVE = 5
    STRONG = 4
    MODERATE = 3
    WEAK = 2
    SPECULATIVE = 1


@dataclass
class LegalPremise:
    """A premise in legal reasoning"""
    premise_id: str
    content: str
    source: str  # statute, case, regulation, etc.
    citation: Optional[str] = None
    reliability: float = 1.0  # 0-1 scale
    jurisdiction: Optional[str] = None


@dataclass
class LegalConclusion:
    """A conclusion from legal reasoning"""
    conclusion_id: str
    content: str
    reasoning_type: ReasoningType
    strength: ArgumentStrength
    supporting_premises: List[str] = field(default_factory=list)
    counter_arguments: List[str] = field(default_factory=list)
    confidence: float = 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "conclusion_id": self.conclusion_id,
            "content": self.content,
            "reasoning_type": self.reasoning_type.name,
            "strength": self.strength.name,
            "supporting_premises": self.supporting_premises,
            "counter_arguments": self.counter_arguments,
            "confidence": self.confidence,
        }


@dataclass
class LegalArgument:
    """A complete legal argument"""
    argument_id: str
    issue: str
    premises: List[LegalPremise]
    conclusion: LegalConclusion
    sub_arguments: List["LegalArgument"] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "argument_id": self.argument_id,
            "issue": self.issue,
            "premises": [
                {
                    "content": p.content,
                    "source": p.source,
                    "citation": p.citation,
                }
                for p in self.premises
            ],
            "conclusion": self.conclusion.to_dict(),
            "sub_arguments": [a.to_dict() for a in self.sub_arguments],
        }


class LegalReasoningEngine:
    """
    Legal Reasoning Engine
    
    Performs legal analysis using multiple reasoning approaches:
    - Rule-based deduction
    - Case-based analogical reasoning
    - Statutory interpretation
    - Policy analysis
    - Precedent analysis
    
    Key capabilities:
    - Issue identification
    - Rule extraction
    - Fact-law matching
    - Argument construction
    - Counter-argument identification
    - Confidence scoring
    """
    
    def __init__(
        self,
        llm_client: Optional[Any] = None,
        embedding_model: Optional[Any] = None,
    ):
        self.llm_client = llm_client
        self.embedding_model = embedding_model
        self.logger = logging.getLogger(f"{__name__}.LegalReasoningEngine")
        
        # Reasoning patterns
        self._statutory_patterns = self._load_statutory_patterns()
        self._case_patterns = self._load_case_patterns()
    
    def _load_statutory_patterns(self) -> Dict[str, Any]:
        """Load statutory interpretation patterns"""
        return {
            "plain_meaning": {
                "description": "Apply ordinary meaning of statutory text",
                "indicators": ["clear", "unambiguous", "plain language"],
                "weight": 0.9,
            },
            "legislative_intent": {
                "description": "Consider legislative history and purpose",
                "indicators": ["legislative history", "committee report", "floor debate"],
                "weight": 0.7,
            },
            "rule_of_lenity": {
                "description": "Construe ambiguous criminal statutes in favor of defendant",
                "indicators": ["criminal", "ambiguous", "penalty"],
                "weight": 0.8,
            },
            "ejusdem_generis": {
                "description": "General words following specific words limited to same class",
                "indicators": ["and other", "including", "such as"],
                "weight": 0.75,
            },
            "expressio_unius": {
                "description": "Expression of one thing excludes others",
                "indicators": ["only", "exclusively", "limited to"],
                "weight": 0.7,
            },
            "in_pari_materia": {
                "description": "Statutes on same subject should be construed together",
                "indicators": ["related statute", "same subject matter"],
                "weight": 0.65,
            },
        }
    
    def _load_case_patterns(self) -> Dict[str, Any]:
        """Load case-based reasoning patterns"""
        return {
            "binding_precedent": {
                "description": "Prior decision from higher court in same jurisdiction",
                "weight": 1.0,
                "factors": ["court_level", "jurisdiction", "relevance"],
            },
            "persuasive_precedent": {
                "description": "Prior decision from other jurisdiction or lower court",
                "weight": 0.6,
                "factors": ["court_reputation", "reasoning_quality", "factual_similarity"],
            },
            "distinguishing": {
                "description": "Identifying material differences from prior cases",
                "weight": 0.8,
                "factors": ["fact_differences", "legal_differences", "policy_differences"],
            },
            "overruling": {
                "description": "Prior precedent no longer valid",
                "weight": 0.9,
                "factors": ["explicit_overruling", "implicit_rejection", "doctrinal_shift"],
            },
        }
    
    # =========================================================================
    # MAIN REASONING METHODS
    # =========================================================================
    
    async def analyze_legal_issue(
        self,
        issue: str,
        facts: List[str],
        applicable_law: List[Dict[str, Any]],
        relevant_cases: Optional[List[Dict[str, Any]]] = None,
        jurisdiction: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Perform comprehensive legal analysis of an issue
        
        Args:
            issue: The legal question to analyze
            facts: List of relevant facts
            applicable_law: Statutes, regulations, and rules
            relevant_cases: Prior cases for analogical reasoning
            jurisdiction: Applicable jurisdiction
            
        Returns:
            Comprehensive analysis with arguments and conclusions
        """
        self.logger.info(f"Analyzing legal issue: {issue[:100]}...")
        
        # Step 1: Identify sub-issues
        sub_issues = await self._identify_sub_issues(issue)
        
        # Step 2: Extract applicable rules
        rules = await self._extract_rules(applicable_law)
        
        # Step 3: Match facts to rules
        fact_rule_matches = await self._match_facts_to_rules(facts, rules)
        
        # Step 4: Perform case-based reasoning if cases provided
        case_analysis = None
        if relevant_cases:
            case_analysis = await self._analyze_precedents(
                issue, facts, relevant_cases, jurisdiction
            )
        
        # Step 5: Construct arguments
        arguments = await self._construct_arguments(
            issue=issue,
            sub_issues=sub_issues,
            facts=facts,
            rules=rules,
            fact_rule_matches=fact_rule_matches,
            case_analysis=case_analysis,
        )
        
        # Step 6: Identify counter-arguments
        counter_arguments = await self._identify_counter_arguments(arguments)
        
        # Step 7: Synthesize conclusions
        conclusions = await self._synthesize_conclusions(
            arguments, counter_arguments
        )
        
        # Step 8: Calculate confidence scores
        analysis = await self._score_analysis(
            arguments, counter_arguments, conclusions
        )
        
        return {
            "issue": issue,
            "jurisdiction": jurisdiction,
            "sub_issues": sub_issues,
            "rules_applied": [r["rule_text"][:200] for r in rules[:5]],
            "fact_rule_matches":
